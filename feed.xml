<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gameFu's Blog</title>
  <id>http://blog.example.com</id>
  <link href="http://blog.example.com"/>
  <link href="http://blog.example.com/feed.xml" rel="self"/>
  <updated>2016-03-08T22:36:00+08:00</updated>
  <author>
    <name>Site Author</name>
  </author>
  <entry>
    <title>centos7下完整配置gitlab及gitlab-ci docker测试</title>
    <link rel="alternate" href="http://blog.example.com/2016/03/08/gitlab_and_ci_deploy/"/>
    <id>http://blog.example.com/2016/03/08/gitlab_and_ci_deploy/</id>
    <published>2016-03-08T22:36:00+08:00</published>
    <updated>2016-03-14T00:12:05+08:00</updated>
    <summary type="html">&lt;h3 id="gitlab下载"&gt;gitlab下载&lt;/h3&gt;

&lt;p&gt;由于直接从官方渠道下载会遭遇被墙的情况，因此，先更换成中国镜像，再进行下载安装&lt;/p&gt;

&lt;p&gt;参照&lt;a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/"&gt;gitlab中国镜像下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装完成后运行下面命令，配置gitlab&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl reconfigure

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="gitlab服务"&gt;gitlab服务&lt;/h3&gt;

&lt;h4 id="开启gitlab服务"&gt;开启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl start

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="停止gitlab服务"&gt;停止gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl stop

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="重启gitlab服务"&gt;重启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl restart

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="开启rails控制台"&gt;开启rails控制台&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-rails console...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;h3 id="gitlab下载"&gt;gitlab下载&lt;/h3&gt;

&lt;p&gt;由于直接从官方渠道下载会遭遇被墙的情况，因此，先更换成中国镜像，再进行下载安装&lt;/p&gt;

&lt;p&gt;参照&lt;a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/"&gt;gitlab中国镜像下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装完成后运行下面命令，配置gitlab&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl reconfigure

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="gitlab服务"&gt;gitlab服务&lt;/h3&gt;

&lt;h4 id="开启gitlab服务"&gt;开启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl start

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="停止gitlab服务"&gt;停止gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl stop

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="重启gitlab服务"&gt;重启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl restart

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="开启rails控制台"&gt;开启rails控制台&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-rails console

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="配置gitlab服务"&gt;配置gitlab服务&lt;/h3&gt;

&lt;p&gt;首先需要修改gitlab的external_url，external_url是gitlab默认仓库的host地址，我们需要将其改成外网可以访问的地址，如ip&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
vim /etc/gitlab/gitlab.rb

&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="n"&gt;external_url&lt;/span&gt; &lt;span class="s1"&gt;'http://121.201.63.89'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们需要配置一下smtp服务器，同样在gitlab.rb&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="c1"&gt;# 配置smtp服务器信息&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_enable'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_address'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"smtp.163.com"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_port'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_user_name'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxuser@163.com"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_password'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxpassword"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_domain'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"163.com"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_authentication'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;:login&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_enable_starttls_auto'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;

&lt;span class="c1"&gt;# 配置发送人信息&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'gitlab_email_from'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxuser@163.com"&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"git_user_email"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxuser@163.com"&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gitlab读取最新更改配置&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl reconfigure

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="配置gitlab-ci"&gt;配置gitlab-ci&lt;/h3&gt;

&lt;h4 id="添加.gitlab-ci.yml-到项目下"&gt;添加.gitlab-ci.yml 到项目下&lt;/h4&gt;

&lt;h4 id="配置gitlab-ci-runner"&gt;配置gitlab-ci runner&lt;/h4&gt;

&lt;p&gt;gitlab-ci runner是负责运行ci测试的服务， runner可以执行多个项目的ci测试&lt;/p&gt;

&lt;p&gt;首先需要先安装gitlab-ci runner&lt;/p&gt;

&lt;p&gt;runner 有许多种形式，这里我们使用了docker的形式运行，使用docker运行有几点好处，一是不用再runner环境下配置ruby运行需要的所有依赖库，降低了配置的难度，同时也避免了由于操作系统，源等差异带来的版本冲突问题&lt;/p&gt;

&lt;p&gt;参照&lt;a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/install/docker.md"&gt;Install as Docker Service&lt;/a&gt;&lt;/p&gt;

&lt;h5 id="note"&gt;note&lt;/h5&gt;

&lt;p&gt;如果遇到&lt;br&gt;
```&lt;br&gt;
ERROR: Build failed with: Get &lt;a href="http://unix.sock/v1.18/version:"&gt;http://unix.sock/v1.18/version:&lt;/a&gt; dial unix /var/run/docker.sock: no such file or directory&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
这是因为没有把docker.sock挂载到容器里，导致无法拉取镜像

这时，run gitlab-runner容器时，需要指定挂载docker.sock

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker run -d --name gitlab-runner --restart always \&lt;br&gt;
  -v /var/run/docker.sock:/var/run/docker.sock \&lt;br&gt;
  -v /srv/gitlab-runner/config:/etc/gitlab-runner \&lt;br&gt;
  gitlab/gitlab-runner:latest&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;

#### 配置.gitlab-ci.yml

```yaml

# 主镜像
image: docker.baozou.com/baozou/dashijian:base
services:
  # 依赖的镜像
  - mysql:latest
# 环境变量
variables:
  # Configure mysql environment variables (https://hub.docker.com/_/mysql/)
  MYSQL_DATABASE: action_cabel
  MYSQL_ROOT_PASSWORD: '63292590'

test:
  script:
    # 拉取子模块
    - git submodule update --init
    # 在gitlab docker runner中/cache是会被挂在容器外面的地方，将bundle下来的gem包安装在这个地方，能避免test每次bundle的时候都重新拉下完整的gem
    - bundle install --path=/cache
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake db:drop
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake db:create
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake db:migrate
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake test
  tags:
    - docker-test


&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>在coreos上用docker部署rails应用</title>
    <link rel="alternate" href="http://blog.example.com/2015/07/09/deploy-docker-passenger-rails-in-coreos/"/>
    <id>http://blog.example.com/2015/07/09/deploy-docker-passenger-rails-in-coreos/</id>
    <published>2015-07-09T12:08:00+08:00</published>
    <updated>2016-03-08T22:38:06+08:00</updated>
    <summary type="html">&lt;h3 id="coreos上的配置"&gt;coreos上的配置&lt;/h3&gt;

&lt;p&gt;coreos没有包管理工具，也不鼓励使用包管理工具来解决依赖关系，他提倡使用docker等容易来解决管理以来，要想搭建一个rails的环境，我们需要创建一个能满足我们需求的镜像。docker原则上是一个服务就需要一个镜像，不同的服务之间通讯需要使用docker自己提供的通讯方式，这个演示实例里，我们只依赖于一个数据库服务。首先我们需要创建我们整个rails运行环境所需要的所有服务镜像&lt;/p&gt;

&lt;p&gt;postgres数据库的官方镜像&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker pull postgres

&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;h3 id="coreos上的配置"&gt;coreos上的配置&lt;/h3&gt;

&lt;p&gt;coreos没有包管理工具，也不鼓励使用包管理工具来解决依赖关系，他提倡使用docker等容易来解决管理以来，要想搭建一个rails的环境，我们需要创建一个能满足我们需求的镜像。docker原则上是一个服务就需要一个镜像，不同的服务之间通讯需要使用docker自己提供的通讯方式，这个演示实例里，我们只依赖于一个数据库服务。首先我们需要创建我们整个rails运行环境所需要的所有服务镜像&lt;/p&gt;

&lt;p&gt;postgres数据库的官方镜像&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker pull postgres

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们还需要运行rails的web服务器镜像，我选择的是passenger的官方镜像&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker pull phusion/passenger-ruby22

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rails运行需要postgres数据库，因此，我们需要创建一个postgres容器,同时给我们创建的容器一个名称&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker run --name gamePostgres -d postgres

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来我们在coreos上的配置就配置好了&lt;/p&gt;

&lt;h3 id="dockerfile"&gt;Dockerfile&lt;/h3&gt;

&lt;p&gt;将这个Dockerfile加入我们的rails项目下&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="c1"&gt;# 以phusion/passenger-ruby22镜像为基础&lt;/span&gt;
&lt;span class="no"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phusion&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;passenger&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ruby22&lt;/span&gt;

&lt;span class="c1"&gt;# 设置时区&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Asia/Shanghai"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="sr"&gt;/etc/&lt;/span&gt;&lt;span class="n"&gt;timezone&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;dpkg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;reconfigure&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;noninteractive&lt;/span&gt; &lt;span class="n"&gt;tzdata&lt;/span&gt;

&lt;span class="c1"&gt;#设置当前环境变量&lt;/span&gt;
&lt;span class="no"&gt;ENV&lt;/span&gt; &lt;span class="no"&gt;HOME&lt;/span&gt; &lt;span class="sr"&gt;/root
#设置rails环境为生产环境
ENV RAILS_ENV production

CMD ["/s&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;my_init&lt;/span&gt;&lt;span class="s2"&gt;"]

# 缓存gem，如果Gemfil没有改变将不会从源直接下载
WORKDIR /tmp
ADD ./Gemfile Gemfile
ADD ./Gemfile.lock Gemfile.lock
RUN bundle install

#启动nginx
RUN rm -f /etc/service/nginx/down
#配置nginx
RUN rm /etc/nginx/sites-enabled/default
ADD nginx.conf /etc/nginx/sites-enabled/webapp.conf

#添加环境文件
ADD nginx-env.conf /etc/nginx/main.d/nginx-env.conf

#增加初始化运行脚本
RUN mkdir -p /etc/my_init.d
#Migrate
ADD migrate.sh /etc/my_init.d/migrate.sh
RUN chmod +x /etc/my_init.d/migrate.sh

# 创建项目目录
RUN mkdir /home/app/webapp
# 将项目文件加入项目目录
ADD . /home/app/webapp

WORKDIR /home/app/webapp
# 编译静态文件
RUN rake assets:precompile

# 清楚产生的缓存文件
RUN apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
# 开放80端口
EXPOSE 80


&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于passenger镜像是建立在nginx的基础上地，所以我们需要配置nginx.同时在跟目录创建nginx.conf.&lt;/p&gt;
&lt;pre class="highlight nginx"&gt;&lt;code&gt;
&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;#指定项目根目录
&lt;/span&gt;    &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="n"&gt;/home/app/webapp/public&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# 开启passenger
&lt;/span&gt;    &lt;span class="kn"&gt;passenger_enabled&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;passenger_user&lt;/span&gt; &lt;span class="s"&gt;app&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;client_max_body_size&lt;/span&gt; &lt;span class="mi"&gt;20M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;passenger_max_request_queue_size&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在docker中服务通讯必须在容器之间暴露端口，因此我们需要添加env文件来暴露各容器之间的端口,在项目根目录下创建nginx-env.conf文件&lt;/p&gt;
&lt;pre class="highlight nginx"&gt;&lt;code&gt;
&lt;span class="c1"&gt;# 暴露服务端口 这个示例中只有postgres服务，因此我们只需要暴露这个端口即可
&lt;/span&gt;&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;POSTGRES_PORT_5432_TCP_ADDR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;POSTGRES_PORT_5432_TCP_PORT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们配置一下.gitignore，在.gitignore文件里加上,因为服务器的数据库配置和本地数据库配置不一样&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;/config/database.yml

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时copy一份database.yml，将其改名为database.yml.sample&lt;/p&gt;

&lt;h3 id="在coreos上部署"&gt;在coreos上部署&lt;/h3&gt;

&lt;p&gt;coreos虽然默认没有带包管理工具，但是安装了git之类的常用工具，因此，我们可以使用git部署我们的项目，将我们的项目上传到github，然后在coreos的某个目录将整个项目拉下来。我选择的是/root/apps目录&lt;/p&gt;

&lt;p&gt;拉取项目后，我们首先需要更改的是数据库配置文件database.yml&lt;/p&gt;
&lt;pre class="highlight yaml"&gt;&lt;code&gt;
&lt;span class="s"&gt;default&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;&amp;amp;default&lt;/span&gt;
  &lt;span class="s"&gt;adapter&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;postgresql&lt;/span&gt;
  &lt;span class="s"&gt;encoding&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;unicode&lt;/span&gt;
  &lt;span class="s"&gt;pool&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;5&lt;/span&gt;
  &lt;span class="s"&gt;timeout&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;5000&lt;/span&gt;
  &lt;span class="s"&gt;username&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;postgres&lt;/span&gt;
  &lt;span class="s"&gt;password&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="c1"&gt;# 通过暴露出来的地址和端口配置数据库&lt;/span&gt;
  &lt;span class="s"&gt;host&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;%= ENV['POSTGRES_PORT_5432_TCP_ADDR'] %&amp;gt;&lt;/span&gt;
  &lt;span class="s"&gt;port&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;%= ENV['POSTGRES_PORT_5432_TCP_PORT'] %&amp;gt;&lt;/span&gt;
&lt;span class="s"&gt;development&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;*default&lt;/span&gt;
  &lt;span class="s"&gt;database&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;sample_dev&lt;/span&gt;

&lt;span class="c1"&gt;# Warning: The database defined as "test" will be erased and&lt;/span&gt;
&lt;span class="c1"&gt;# re-generated from your development database when you run "rake".&lt;/span&gt;
&lt;span class="c1"&gt;# Do not set this db to the same as development or production.&lt;/span&gt;
&lt;span class="s"&gt;test&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;*default&lt;/span&gt;
  &lt;span class="s"&gt;database&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;sample_test&lt;/span&gt;

&lt;span class="s"&gt;production&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;*default&lt;/span&gt;
  &lt;span class="s"&gt;database&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;sample_production&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入项目根目录，通过Dockfile构建一个镜像,并且给自己创建的镜像一个名称&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker build -t game/ruby_sample .

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后的每一次更改项目内容都需要重新构建一个新的镜像，如果你是第一次生成容器可以不用运行下面这条命令，如果你之前已经创建过同名的容易就需要将其删除，如我之前这个容器名为gameRuby_sample,那么我就需要将这个容器删除后重新创建&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker rm -f gameRuby_sample

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建新的容器，并且建立容器之间的通讯，监听服务器的80端口&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker run --name gameRuby_sample --link gamePostgres:postgres -d -p 80:80 game/ruby_sample

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行到这里，一个完整的rails容器已经基本建立完成了。然而整个容器还缺乏一个很关键的部分没解决，就是运行rails程序的migrate，由于，migrate必须在整个容器建立完成之后才能运行，因此无法直接将其写在&lt;code&gt;Dockerfile&lt;/code&gt;内，只有当运行容器时运行，才能有效果。&lt;br&gt;
passenger是根据ubuntu镜像的基础上搭建的，也就是说，这个系统的启动流程跟ubuntu启动的流程是一样的，当ubuntu系统完成引导后，操作系统会去检查/etc/my_init.d/目录下的脚本，并且会运行，这样一来，只需把migrate的执行脚本放到这个目录下面，那么就会在镜像启动的时候运行Migrate。&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="c1"&gt;#增加初始化运行脚本&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="sr"&gt;/etc/m&lt;/span&gt;&lt;span class="n"&gt;y_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;d&lt;/span&gt;
&lt;span class="c1"&gt;#Migrate&lt;/span&gt;
&lt;span class="no"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;migrate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sh&lt;/span&gt; &lt;span class="sr"&gt;/etc/m&lt;/span&gt;&lt;span class="n"&gt;y_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;migrate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sh&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="sr"&gt;/etc/m&lt;/span&gt;&lt;span class="n"&gt;y_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;migrate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sh&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是migrate运行脚本&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"start migrate"&lt;/span&gt;
bash -c &lt;span class="s1"&gt;'cd /home/app/webapp; bundle exec rake db:migrate'&lt;/span&gt;;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"migrate finshed"&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要运行docker run后，运行&lt;code&gt;docker logs -f 镜像名&lt;/code&gt;，能看到&lt;code&gt;start migrate&lt;/code&gt;和&lt;code&gt;migrate finshed&lt;/code&gt;就说明镜像已经成功运行migrate了&lt;/p&gt;

&lt;p&gt;这样一来基本的rails运行环境就搭建完成了&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>coreos中更改docker镜像地址</title>
    <link rel="alternate" href="http://blog.example.com/2015/07/06/coreos-modify-docker-registry-mirror/"/>
    <id>http://blog.example.com/2015/07/06/coreos-modify-docker-registry-mirror/</id>
    <published>2015-07-06T23:45:00+08:00</published>
    <updated>2015-07-07T00:25:43+08:00</updated>
    <summary type="html">&lt;p&gt;由于&lt;code&gt;docker&lt;/code&gt;的不断成熟，docker在实际生产环境中的应用已经得到越来越多的印证，因此，公司项目想从原来的Mina部署转为&lt;code&gt;docker&lt;/code&gt;部署，但是docker仓库由于在国内没有cdn，导致镜像下载速度无比的缓慢，所以决定换成国内镜像，由于操作系统是使用&lt;code&gt;coreos&lt;/code&gt;，无论国内外资料都非常少，因此途中爬了很多坑，这篇文章是我爬坑的总结&lt;/p&gt;

&lt;h3 id="docker国内镜像"&gt;docker国内镜像&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;是目前炙手可热的云计算开源项目，随着docker不断发展，不久前，国内第一家基于&lt;code&gt;docker&lt;/code&gt;技术的一站式容器云平台daocloud...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;由于&lt;code&gt;docker&lt;/code&gt;的不断成熟，docker在实际生产环境中的应用已经得到越来越多的印证，因此，公司项目想从原来的Mina部署转为&lt;code&gt;docker&lt;/code&gt;部署，但是docker仓库由于在国内没有cdn，导致镜像下载速度无比的缓慢，所以决定换成国内镜像，由于操作系统是使用&lt;code&gt;coreos&lt;/code&gt;，无论国内外资料都非常少，因此途中爬了很多坑，这篇文章是我爬坑的总结&lt;/p&gt;

&lt;h3 id="docker国内镜像"&gt;docker国内镜像&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;是目前炙手可热的云计算开源项目，随着docker不断发展，不久前，国内第一家基于&lt;code&gt;docker&lt;/code&gt;技术的一站式容器云平台daocloud正式推出了，同时也给国内广大docker爱好者带来了docker的免费国内镜像.前往docker的官网注册一个账号登录后就能得到一个免费的docker镜像地址，如&lt;a href="http://xxx.m.daocloud.io"&gt;http://xxx.m.daocloud.io&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="关于coreos"&gt;关于coreos&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;coreos&lt;/code&gt;是一个高度精简的linux操作系统，将许多原本需要复杂人工操作或者第三方软件支持的功能在操作系统级别进行了实现，同时剔除了其他对于服务器系统非核心的软件，比如GUI和包管理器。&lt;code&gt;coreos&lt;/code&gt;并不鼓励用户将各种应用软件直接安装在操作系统之上，而是提倡将所有服务运行在单独的应用容器中，由应用容器提供应用所需要的基础功能环境。这种做法将操作系统和应用程序的职责做了更彻底的分离，降低操作系统和应用程序的耦合度，使运行这些服务器的公司可以更快速、更廉价地更新自己的线上业务。&lt;br&gt;
正式这种特性，&lt;code&gt;coreos&lt;/code&gt;可以说十分适合用来部署&lt;code&gt;docker&lt;/code&gt;服务&lt;/p&gt;

&lt;h3 id="更改docker镜像地址"&gt;更改docker镜像地址&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;在&lt;code&gt;coreos&lt;/code&gt;中是一个服务，在&lt;code&gt;coreos&lt;/code&gt;中没一个服务都由一个unit文件来定义，&lt;code&gt;docker&lt;/code&gt;的unit文件在&lt;code&gt;usr/lib/systemd/system/docker.service&lt;/code&gt;,我们需要将它拷贝出来将其放在docker服务启动时会加载的位置&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
cp /usr/lib/systemd/system/docker.service /etc/systemd/system

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开这种文件，我们会发现里面有一个更改docker镜像地址的关键环境变量&lt;code&gt;$DOCKER_OPTS&lt;/code&gt;，而更改镜像地址的本质就是更改&lt;code&gt;$DOCKER_OPTS&lt;/code&gt;的值。&lt;br&gt;
这个环境变量的值是在&lt;code&gt;/run/flannel_docker_opts.env&lt;/code&gt;中设置的，如果你的系统里没有这个文件，就自己添加一个这个文件&lt;/p&gt;

&lt;p&gt;往这个文件里添加从daocloud上获取的镜像地址&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="nv"&gt;DOCKER_OPTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"--registry-mirror=http://xxxx.m.daocloud.io"&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完成后，运行&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
sudo systemctl daemon-reload
sudo systemctl restart docker

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 &lt;code&gt;ps aux&lt;/code&gt; 如果能看到&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
root      1725  0.6  1.7 221400 18328 ?        Ssl  15:27   0:00 docker --daemon --host&lt;span class="o"&gt;=&lt;/span&gt;fd:// --registry-mirror&lt;span class="o"&gt;=&lt;/span&gt;http://xxx.m.daocloud

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么就大功告成了&lt;/p&gt;

&lt;h3 id="总结"&gt;总结&lt;/h3&gt;

&lt;p&gt;虽然整个配置流程看起来并不复杂，但是使用比较新的技术难免要爬坑，由于国内外资料都非常的少，导致爬坑异常的艰难，希望大家能节省爬过这个坑的时间。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>在rails中使用jwt实现授权和权限控制</title>
    <link rel="alternate" href="http://blog.example.com/2015/06/22/rails-jwt/"/>
    <id>http://blog.example.com/2015/06/22/rails-jwt/</id>
    <published>2015-06-22T17:45:00+08:00</published>
    <updated>2015-06-22T21:44:53+08:00</updated>
    <summary type="html">&lt;h2 id="关于jwt"&gt;关于jwt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt; 全称&lt;code&gt;json_web_token&lt;/code&gt;，是一种高效可靠的数字签名解决标准，它可以携带自定义用户信息，经过 base64 编码, hamc SHA256 加密生成 token, 然后通过 http authorization 请求头传递作为登陆凭证。在&lt;code&gt;RESTful API&lt;/code&gt;越来越流行的情况下，传统的cookie, session携带授权令牌很难满足需求了，两者都会带来业务上拓展的困难。&lt;/p&gt;

&lt;h2 id="登录流程"&gt;登录流程&lt;/h2&gt;

&lt;p&gt;首先，用户端会首先检查本地有没有缓存jwt，如果有，直接在请求头上带上jwt...&lt;/p&gt;</summary>
    <content type="html">&lt;h2 id="关于jwt"&gt;关于jwt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt; 全称&lt;code&gt;json_web_token&lt;/code&gt;，是一种高效可靠的数字签名解决标准，它可以携带自定义用户信息，经过 base64 编码, hamc SHA256 加密生成 token, 然后通过 http authorization 请求头传递作为登陆凭证。在&lt;code&gt;RESTful API&lt;/code&gt;越来越流行的情况下，传统的cookie, session携带授权令牌很难满足需求了，两者都会带来业务上拓展的困难。&lt;/p&gt;

&lt;h2 id="登录流程"&gt;登录流程&lt;/h2&gt;

&lt;p&gt;首先，用户端会首先检查本地有没有缓存jwt，如果有，直接在请求头上带上jwt去访问你的api,然后api检查这个jwt是否合法，如果合法，则通过，返回这个api请求到的信息，如果不合法返回错误信息。 如果本地没有缓存jwt，那么访问api时，api会引导用户去获取jwt，并记住之前访问的url，当用户通过输入短信验证码（或者其他方式）,获取到jwt后在请求头上带上这个jwt去访问原来访问的url&lt;/p&gt;

&lt;h2 id="在ruby-on-rails下使用jwt"&gt;在ruby on rails下使用jwt&lt;/h2&gt;

&lt;p&gt;在Gemfile中添加&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="n"&gt;gem&lt;/span&gt; &lt;span class="s1"&gt;'jwt'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 bundle 进行安装&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
bundle

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是获取jwt, 我把他定义在一个名为json_web_token的controller中&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;

    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:auth_type&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s1"&gt;'user'&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;verify_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request_phone_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request_verify_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_by&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:phone_number&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;request_phone_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

          &lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;
            &lt;span class="c1"&gt;#创建新的用户&lt;/span&gt;
            &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:phone_number&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;request_phone_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
          &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="no"&gt;LogicError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'验证码不正确'&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
      &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s1"&gt;'operation_user'&lt;/span&gt;
        &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;OperationUser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:username&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:password&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="s1"&gt;'base_station_user'&lt;/span&gt;
        &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;BaseStationUser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:username&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:password&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;
      &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="no"&gt;LogicError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'用户名或密码错误'&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;# 返回生成的jwt&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;as_json&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;methods: :token&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;response_json&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，请求这个方法的时候必须要带上一个参数是 auth_type这个参数表示登录用户的角色，不同的角色需要携带不同的参数，如user需要携带的是手机号，短信验证码，而operation_user需要携带的是用户名，密码，&lt;br&gt;
根据不同的用户类型来判断,例如，这段代码验证了手机验证码是否正确&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;verify_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request_phone_number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;request_verify_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_by&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:phone_number&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;request_phone_number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果，通过了验证，那么返回jwt。在models的 concerns目录下创建 json_web_token_able.rb，这个文件里的代码是用来生成jwt的&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;JsonWebTokenAble&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;to_jwt&lt;/span&gt;
    &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;# key为用户角色，value为用户id&lt;/span&gt;
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="ss"&gt;:user_id&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;id&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="c1"&gt;# 设置过期时间&lt;/span&gt;
        &lt;span class="s1"&gt;'exp'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;month&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;from_now&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;to_i&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;# 第二个参数为自己配置的密钥&lt;/span&gt;
    &lt;span class="no"&gt;JWT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;ENV&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"SECRET_KEY_BASE"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kp"&gt;alias_method&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:to_jwt&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在各种角色的用户模型里引进（业务需求并不需要动态建立角色，直接建立不同角色的模型，你可以根据你的业务需要进行调整）&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;JsonWebTokenAble&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如同我的业务需求一样，我需要在返回的时候将用户的信息返回回来该如何做呢,在models地 concerns目录下创建 auth_able.rb,&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;AuthAble&lt;/span&gt;

  &lt;span class="c1"&gt;# 扩展类方法&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;ClassMethods&lt;/span&gt;
    &lt;span class="c1"&gt;# 返回user对象&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;identity&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_by&lt;/span&gt; &lt;span class="ss"&gt;username: &lt;/span&gt;&lt;span class="n"&gt;identity&lt;/span&gt;
      &lt;span class="c1"&gt;# 匹配用户名密码&lt;/span&gt;
      &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;false&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# 扩展的实例方法&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;InstanceMethods&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;authenticate&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;# 将密码令牌排除&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;as_json&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kp"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;opts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;except: &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"password_digest"&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
      &lt;span class="k"&gt;super&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# 将扩展的类方法和实例方法包含到模型中&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;included&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;extend&lt;/span&gt;         &lt;span class="no"&gt;ClassMethods&lt;/span&gt;
    &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;send&lt;/span&gt; &lt;span class="ss"&gt;:include&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;InstanceMethods&lt;/span&gt;

    &lt;span class="c1"&gt;# 可验证模型的配置&lt;/span&gt;
    &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;has_secure_password&lt;/span&gt; &lt;span class="ss"&gt;validations: &lt;/span&gt;&lt;span class="kp"&gt;false&lt;/span&gt;
    &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;presence: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟json_web_token_able.rb一样，只需要在模型中引入就可以&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;AuthAble&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户获取到jwt后，就应该需要判断jwt是否合法，我们可以建立一个helper来进行判断&lt;/p&gt;

&lt;p&gt;json_web_token_helper.rb&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
  &lt;span class="c1"&gt;#从请求头获取 jwt&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;request_jwt&lt;/span&gt;
    &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Token"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# 解析jwt 如果不合法 抛出异常&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;jwt_claim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jwt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;begin&lt;/span&gt;
      &lt;span class="no"&gt;JWT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jwt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;ENV&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"SECRET_KEY_BASE"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  
    &lt;span class="k"&gt;rescue&lt;/span&gt;
      &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="no"&gt;AuthError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'未授权的请求'&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# 获取用户id&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;jwt_user_id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jwt_claim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;auth_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kp"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="n"&gt;auth_type&lt;/span&gt;
      &lt;span class="n"&gt;auth_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user_type&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;begin&lt;/span&gt;
      &lt;span class="c1"&gt;# 判断用户类型是否合法&lt;/span&gt;
      &lt;span class="n"&gt;jwt_claim&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;auth_type&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s2"&gt;"user_id"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;rescue&lt;/span&gt;
      &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="no"&gt;AuthError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'未授权用户'&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# 返回当前登录用户id&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;request_jwt_user_id&lt;/span&gt;
    &lt;span class="n"&gt;meta_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user_type&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;constantize&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;meta_class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_by&lt;/span&gt; &lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;jwt_user_id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jwt_claim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request_jwt&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="n"&gt;jwt_user_id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jwt_claim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request_jwt&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="no"&gt;AuthError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'未授权用户'&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# 获取当前登录用户&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;current_user&lt;/span&gt;
    &lt;span class="n"&gt;meta_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user_type&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;constantize&lt;/span&gt;
    &lt;span class="vi"&gt;@current_user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;meta_class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;find_by&lt;/span&gt; &lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;request_jwt_user_id&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;#用户类名 用来支持多表用户&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;user_type&lt;/span&gt;
    &lt;span class="vi"&gt;@user_type&lt;/span&gt; &lt;span class="o"&gt;||=&lt;/span&gt; &lt;span class="s1"&gt;'User'&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;user_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_type_params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="vi"&gt;@user_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user_type_params&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kp"&gt;alias_method&lt;/span&gt; &lt;span class="ss"&gt;:current_user_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:request_jwt_user_id&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要将这个helper引入controller中就行了，由于这里面的函数会用的比较频繁，你可以选择跟我一样，将其引入到application_controller.rb中&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;Backend&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;JsonWebTokenHelper&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要想验证jwt是否合法，只需要在controller中调用&lt;code&gt;current_user&lt;/code&gt;就能判断。&lt;/p&gt;

&lt;p&gt;那么如何根据jwt来判断不同类型的用户呢？ 在json_web_token_helper.rb里我们预留了一个函数用来设置用户类型，这样检查jwt时候合法的时候就会去检查jwt中的用户类型是否正确&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;user_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user_type_params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="vi"&gt;@user_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user_type_params&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来要做的是就很简单了，比如base_station下的所有控制器只要去继承一个设置了用户类型的新的公共控制器就可以达到权限控制的效果了&lt;/p&gt;

&lt;p&gt;base_controller.rb&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
  &lt;span class="n"&gt;before_action&lt;/span&gt; &lt;span class="ss"&gt;:set_user_type&lt;/span&gt;

  &lt;span class="kp"&gt;private&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;set_user_type&lt;/span&gt;
    &lt;span class="vi"&gt;@user_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'BastationUser'&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后需要在你以&lt;code&gt;BastationUser&lt;/code&gt;用户操作的控制器只要全部继承这个base_controller.rb就行了，其他用户的权限控制也是类似操作，至此，jwt做授权和权限控制就完成了&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby on Rails 终极部署方案 nginx+mina+puma</title>
    <link rel="alternate" href="http://blog.example.com/2015/06/18/rails-nginx-mina-puma/"/>
    <id>http://blog.example.com/2015/06/18/rails-nginx-mina-puma/</id>
    <published>2015-06-18T22:43:00+08:00</published>
    <updated>2015-06-19T00:46:25+08:00</updated>
    <summary type="html">&lt;h2 id="搭建工具介绍"&gt;搭建工具介绍&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Ruby on Rails&lt;/code&gt;作为一款十分优秀的web开发框架，在当前web领域中慢慢占据了越来越重要，秉承rails快速开发的特点，很多快速部署rails的方案也越来越多。这篇文章中所选的方案是我个人认为十分优秀的部署方案。这套部署方案的结构是，&lt;code&gt;nginx&lt;/code&gt;作为反向代理服务器负责负载均衡，&lt;code&gt;mina&lt;/code&gt;作为自动化部署工具，&lt;code&gt;puma&lt;/code&gt;作为rails的web服务器&lt;/p&gt;

&lt;h3 id="nginx"&gt;nginx&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;nginx&lt;/code&gt;是一款优秀的代理服务器，其高效的性能已经得到了业界的广泛认可，相信作为web开发人员不会没听说过他的...&lt;/p&gt;</summary>
    <content type="html">&lt;h2 id="搭建工具介绍"&gt;搭建工具介绍&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Ruby on Rails&lt;/code&gt;作为一款十分优秀的web开发框架，在当前web领域中慢慢占据了越来越重要，秉承rails快速开发的特点，很多快速部署rails的方案也越来越多。这篇文章中所选的方案是我个人认为十分优秀的部署方案。这套部署方案的结构是，&lt;code&gt;nginx&lt;/code&gt;作为反向代理服务器负责负载均衡，&lt;code&gt;mina&lt;/code&gt;作为自动化部署工具，&lt;code&gt;puma&lt;/code&gt;作为rails的web服务器&lt;/p&gt;

&lt;h3 id="nginx"&gt;nginx&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;nginx&lt;/code&gt;是一款优秀的代理服务器，其高效的性能已经得到了业界的广泛认可，相信作为web开发人员不会没听说过他的大名&lt;/p&gt;

&lt;h3 id="mina"&gt;mina&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mina&lt;/code&gt;是一款由ruby开发的自动化部署工具，其目的是为了简化每次rails代码提交时的部署，一键完成部署，杜绝了提交到git服务器后，又去服务器上git pull的情况&lt;/p&gt;

&lt;h3 id="puma"&gt;puma&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;puma&lt;/code&gt;是一款专门针对rails的并发服务器，相对于&lt;code&gt;passenger&lt;/code&gt;，&lt;code&gt;puma&lt;/code&gt;可配置面更广，而且性能比&lt;code&gt;passenger&lt;/code&gt;更高，是rails web服务器的不二之选&lt;/p&gt;

&lt;h2 id="部署前言"&gt;部署前言&lt;/h2&gt;

&lt;p&gt;由于这篇文章需要很多铺垫，包括rails的安装下载,git的配置等等，需要读者自己去查阅资料或者查阅之前我写过的一些文章，如果期间有什么问题，请留言。。&lt;/p&gt;

&lt;h2 id="mina"&gt;mina&lt;/h2&gt;

&lt;p&gt;首先在你的rails项目的&lt;code&gt;Gemfile&lt;/code&gt;中加上&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="n"&gt;gem&lt;/span&gt; &lt;span class="n"&gt;mina&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;code&gt;bundle&lt;/code&gt; 安装 &lt;code&gt;mina&lt;/code&gt;，接着在你的rails项目根目录初始化&lt;code&gt;mina&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;mina init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是在你项目的config目录下会有一个&lt;code&gt;deploy.rb&lt;/code&gt;，配置&lt;code&gt;deploy.rb&lt;/code&gt;，列出重点部分，每一行的解释会附在代码的注释里&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="c1"&gt;#服务器地址,是使用ssh的方式登录服务器&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;:domain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'root@192.168.0.103'&lt;/span&gt;
&lt;span class="c1"&gt;#服务器中项目部署位置&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;:deploy_to&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'/var/www/ruby_sample'&lt;/span&gt;
&lt;span class="c1"&gt;#git代码仓库&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;:repository&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'https://github.com/gameFu/ruby_sample.git'&lt;/span&gt;
&lt;span class="c1"&gt;#git分支&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;:branch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'master'&lt;/span&gt;

&lt;span class="c1"&gt;# 中括号里的文件 会出现在服务器项目附录的shared文件夹中，这里加入了secrets.yml，环境密钥无需跟开发计算机一样&lt;/span&gt;
&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;:shared_paths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'config/database.yml'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'log'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'config/secrets.yml'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# 这个块里面的代码表示运行 mina setup时运行的命令&lt;/span&gt;
&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="ss"&gt;:setup&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:environment&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;

  &lt;span class="c1"&gt;# 在服务器项目目录的shared中创建log文件夹&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[mkdir -p "#{deploy_to}/#{shared_path}/log"]&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[chmod g+rx,u+rwx "#{deploy_to}/#{shared_path}/log"]&lt;/span&gt;

  &lt;span class="c1"&gt;# 在服务器项目目录的shared中创建config文件夹 下同&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[mkdir -p "#{deploy_to}/#{shared_path}/config"]&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[chmod g+rx,u+rwx "#{deploy_to}/#{shared_path}/config"]&lt;/span&gt;

  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[touch "#{deploy_to}/#{shared_path}/config/database.yml"]&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[touch "#{deploy_to}/#{shared_path}/config/secrets.yml"]&lt;/span&gt;

  &lt;span class="c1"&gt;# puma.rb 配置puma必须得文件夹及文件&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[mkdir -p "#{deploy_to}/shared/tmp/pids"]&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[chmod g+rx,u+rwx "#{deploy_to}/shared/tmp/pids"]&lt;/span&gt;

  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[mkdir -p "#{deploy_to}/shared/tmp/sockets"]&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[chmod g+rx,u+rwx "#{deploy_to}/shared/tmp/sockets"]&lt;/span&gt;

  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[touch "#{deploy_to}/shared/config/puma.rb"]&lt;/span&gt;
  &lt;span class="n"&gt;queue&lt;/span&gt;  &lt;span class="sx"&gt;%[echo "-----&amp;gt; Be sure to edit 'shared/config/puma.rb'."]&lt;/span&gt;

  &lt;span class="c1"&gt;# tmp/sockets/puma.state&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[touch "#{deploy_to}/shared/tmp/sockets/puma.state"]&lt;/span&gt;
  &lt;span class="n"&gt;queue&lt;/span&gt;  &lt;span class="sx"&gt;%[echo "-----&amp;gt; Be sure to edit 'shared/tmp/sockets/puma.state'."]&lt;/span&gt;

  &lt;span class="c1"&gt;# log/puma.stdout.log&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[touch "#{deploy_to}/shared/log/puma.stdout.log"]&lt;/span&gt;
  &lt;span class="n"&gt;queue&lt;/span&gt;  &lt;span class="sx"&gt;%[echo "-----&amp;gt; Be sure to edit 'shared/log/puma.stdout.log'."]&lt;/span&gt;

  &lt;span class="c1"&gt;# log/puma.stdout.log&lt;/span&gt;
  &lt;span class="n"&gt;queue!&lt;/span&gt; &lt;span class="sx"&gt;%[touch "#{deploy_to}/shared/log/puma.stderr.log"]&lt;/span&gt;
  &lt;span class="n"&gt;queue&lt;/span&gt;  &lt;span class="sx"&gt;%[echo "-----&amp;gt; Be sure to edit 'shared/log/puma.stderr.log'."]&lt;/span&gt;

  &lt;span class="n"&gt;queue&lt;/span&gt;  &lt;span class="sx"&gt;%[echo "-----&amp;gt; Be sure to edit '#{deploy_to}/#{shared_path}/config/database.yml'."]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;#这个代码块表示运行 mina deploy时执行的命令&lt;/span&gt;
&lt;span class="n"&gt;desc&lt;/span&gt; &lt;span class="s2"&gt;"Deploys the current version to the server."&lt;/span&gt;
&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="ss"&gt;:deploy&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:environment&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="ss"&gt;:before_hook&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;deploy&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="c1"&gt;#重新拉git服务器上的最新版本，即使没有改变&lt;/span&gt;
    &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="ss"&gt;:'git:clone'&lt;/span&gt;
    &lt;span class="c1"&gt;#重新设定shared_path位置&lt;/span&gt;
    &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="ss"&gt;:'deploy:link_shared_paths'&lt;/span&gt;
    &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="ss"&gt;:'bundle:install'&lt;/span&gt;
    &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="ss"&gt;:'rails:db_migrate'&lt;/span&gt;
    &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="ss"&gt;:'rails:assets_precompile'&lt;/span&gt;
    &lt;span class="n"&gt;invoke&lt;/span&gt; &lt;span class="ss"&gt;:'deploy:cleanup'&lt;/span&gt;

    &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="ss"&gt;:launch&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="s2"&gt;"mkdir -p &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;deploy_to&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;current_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/tmp/"&lt;/span&gt;
      &lt;span class="c1"&gt;# queue "chown -R www-data #{deploy_to}"&lt;/span&gt;
      &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="s2"&gt;"touch &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;deploy_to&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;current_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/tmp/restart.txt"&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来mina的基本配置就完成，接下来只要将你开发环境的项目上传到git服务器，然后运行下面的命令就完成了&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;mina deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成部署后，你就可以在指定的服务器目录下看到你的项目，目录结构如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;current -当前版本目录也就是项目目录&lt;/li&gt;
&lt;li&gt;last_version -版本号&lt;/li&gt;
&lt;li&gt;releases/ -过去的版本&lt;/li&gt;
&lt;li&gt;scm/&lt;/li&gt;
&lt;li&gt;shared/ 先前shared_path所设定另外拉出来的文件都在这里&lt;/li&gt;
&lt;li&gt;tmp/&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里需要注意的几点&lt;br&gt;
1.shared_path里面的文件不仅仅是表示这些文件会在服务器目录中出现在另外的目录里，也表示这些文件或者目录不会受到git版本库的控制，也就是说这些文件的配置必须在你服务器中手动去配置，这两个文件包括database.yml和secrets.yml,在shared/config目录下&lt;br&gt;
2.针对deploy最好在服务器创建一个使用者，并针对他创建一个ssh authorized_keys,这里直接使用了root身份，参考&lt;a href="http://segmentfault.com/a/1190000002911599"&gt;centos7 服务器部署ssh证书授权登录&lt;/a&gt;，这样做能避免每次部署的时候都需要输入服务器账号密码&lt;/p&gt;

&lt;h3 id="可能会遇到的问题"&gt;可能会遇到的问题&lt;/h3&gt;

&lt;p&gt;由于生产环境一般会搭配类似于&lt;code&gt;postgresql&lt;/code&gt;等成熟数据库，这里我就举出一个搭建&lt;code&gt;postgresql&lt;/code&gt;，首先是启动数据库时（centos 7下），如果遇到问题请使用下面的命令就能看到详细的错误信息&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;systemctl status postgresql-9.4.service -l 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在跑&lt;code&gt;mina deploy&lt;/code&gt;时可能会报类似于这样的一个错误&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt; Gem::LoadError: Specified 'postgresql' for database adapter, but the gem is not loaded. Add `gem 'pg'` to your Gemfile (and ensure its version is at the minimum required by ActiveRecord).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从错误信息上能很明显的看出是因为没有安装pg这个包导致的，但是有一种情况是明明在项目的&lt;code&gt;Gemfile&lt;/code&gt;上写上了pg但还是跑不过，造成这个的原因，可能是由于你的服务器环境缺少了pg的头文件导致的，如果是在centos下，只需要执行下面命令就能解决&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;yum install postgresql-libs
yum install postgresql-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="puma"&gt;Puma&lt;/h3&gt;

&lt;p&gt;首先在你的&lt;code&gt;Gemfile&lt;/code&gt;里加上&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="n"&gt;gem&lt;/span&gt; &lt;span class="n"&gt;puma&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在config目录下手动创建一个&lt;code&gt;puma.rb&lt;/code&gt;文件，配置&lt;code&gt;puma.rb&lt;/code&gt;文件&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="c1"&gt;#!/usr/bin/env puma&lt;/span&gt;

&lt;span class="c1"&gt;#rails的运行环境&lt;/span&gt;
&lt;span class="n"&gt;environment&lt;/span&gt; &lt;span class="s1"&gt;'production'&lt;/span&gt;
&lt;span class="n"&gt;threads&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;
&lt;span class="n"&gt;workers&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;

&lt;span class="c1"&gt;#项目名&lt;/span&gt;
&lt;span class="n"&gt;app_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"ruby_sample"&lt;/span&gt;
&lt;span class="c1"&gt;#项目路径&lt;/span&gt;
&lt;span class="n"&gt;application_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"/var/www/&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;app_name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="c1"&gt;#这里一定要配置为项目路径下地current&lt;/span&gt;
&lt;span class="n"&gt;directory&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/current"&lt;/span&gt;

&lt;span class="c1"&gt;#下面都是 puma的配置项&lt;/span&gt;
&lt;span class="n"&gt;pidfile&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/shared/tmp/pids/puma.pid"&lt;/span&gt;
&lt;span class="n"&gt;state_path&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/shared/tmp/sockets/puma.state"&lt;/span&gt;
&lt;span class="n"&gt;stdout_redirect&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/shared/log/puma.stdout.log"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/shared/log/puma.stderr.log"&lt;/span&gt;
&lt;span class="n"&gt;bind&lt;/span&gt; &lt;span class="s2"&gt;"unix://&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/shared/tmp/sockets/&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;app_name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;.sock"&lt;/span&gt;
&lt;span class="n"&gt;activate_control_app&lt;/span&gt; &lt;span class="s2"&gt;"unix://&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;application_path&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/shared/tmp/sockets/pumactl.sock"&lt;/span&gt;

&lt;span class="c1"&gt;#后台运行&lt;/span&gt;
&lt;span class="n"&gt;daemonize&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;on_restart&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s1"&gt;'On restart...'&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;preload_app!&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的地方&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;threads&lt;/code&gt; - &lt;code&gt;puma&lt;/code&gt;的线程数，第一个参数是最小的线程数，第二个参数是最大线程数&lt;/li&gt;
&lt;li&gt;bind - 这个指定的是&lt;code&gt;puma&lt;/code&gt;运行时产生的&lt;code&gt;socket&lt;/code&gt;，后面&lt;code&gt;nginx&lt;/code&gt;会用到&lt;/li&gt;
&lt;li&gt;这里所有对应的目录是在&lt;code&gt;deploy&lt;/code&gt;配置中配置的，如果需要更改配置目录，&lt;code&gt;deploy.rb&lt;/code&gt;也需要相应的更改&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="nginx"&gt;Nginx&lt;/h2&gt;

&lt;p&gt;下载安装&lt;code&gt;nginx&lt;/code&gt;后，打开&lt;code&gt;nginx&lt;/code&gt;的配置文件&lt;code&gt;nginx.conf&lt;/code&gt;进行配置&lt;/p&gt;
&lt;pre class="highlight nginx"&gt;&lt;code&gt;  &lt;span class="k"&gt;worker_processes&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="k"&gt;error_log&lt;/span&gt;  &lt;span class="n"&gt;/var/log/nginx/error.log&lt;/span&gt; &lt;span class="s"&gt;warn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;pid&lt;/span&gt;        &lt;span class="n"&gt;/var/run/nginx.pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="k"&gt;events&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="kn"&gt;worker_connections&lt;/span&gt;  &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="kn"&gt;include&lt;/span&gt;       &lt;span class="n"&gt;/etc/nginx/mime.types&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="kn"&gt;default_type&lt;/span&gt;  &lt;span class="nc"&gt;application/octet-stream&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

          &lt;span class="kn"&gt;log_format&lt;/span&gt;  &lt;span class="s"&gt;main&lt;/span&gt;  &lt;span class="s"&gt;'&lt;/span&gt;&lt;span class="nv"&gt;$remote_addr&lt;/span&gt; &lt;span class="s"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;$remote_user&lt;/span&gt; &lt;span class="s"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$time_local&lt;/span&gt;&lt;span class="s"&gt;]&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$request&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="s"&gt;'&lt;/span&gt;
                            &lt;span class="s"&gt;'&lt;/span&gt;&lt;span class="nv"&gt;$status&lt;/span&gt; &lt;span class="nv"&gt;$body_bytes_sent&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$http_referer&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="s"&gt;'&lt;/span&gt;
                            &lt;span class="s"&gt;'"&lt;/span&gt;&lt;span class="nv"&gt;$http_user_agent&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$http_x_forwarded_for&lt;/span&gt;&lt;span class="s"&gt;"'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

          &lt;span class="kn"&gt;access_log&lt;/span&gt;  &lt;span class="n"&gt;/var/log/nginx/access.log&lt;/span&gt;  &lt;span class="s"&gt;main&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

          &lt;span class="kn"&gt;sendfile&lt;/span&gt;        &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="c1"&gt;#tcp_nopush     on;
&lt;/span&gt;
          &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt;  &lt;span class="mi"&gt;65&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

          &lt;span class="c1"&gt;#gzip  on;
&lt;/span&gt;
          &lt;span class="c1"&gt;#include /etc/nginx/conf.d/*.conf;
&lt;/span&gt;          &lt;span class="kn"&gt;upstream&lt;/span&gt; &lt;span class="s"&gt;deploy&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                  &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="s"&gt;unix:///var/www/ruby_sample/shared/tmp/sockets/ruby_sample.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;

          &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;your.server.domain.ip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;# change to match your URL
&lt;/span&gt;              &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="n"&gt;/var/www/ruby_sample/current/public&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;# I assume your app is located at this location
&lt;/span&gt;
              &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="n"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                  &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://deploy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;# match the name of upstream directive which is defined above
&lt;/span&gt;                  &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt; &lt;span class="s"&gt;Host&lt;/span&gt; &lt;span class="nv"&gt;$host&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                  &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt; &lt;span class="s"&gt;X-Forwarded-For&lt;/span&gt; &lt;span class="nv"&gt;$proxy_add_x_forwarded_for&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt;

              &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt;&lt;span class="sr"&gt;*&lt;/span&gt; &lt;span class="s"&gt;^/assets/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                  &lt;span class="c1"&gt;# Per RFC2616 - 1 year maximum expiry
&lt;/span&gt;                  &lt;span class="kn"&gt;expires&lt;/span&gt; &lt;span class="s"&gt;1y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                  &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;Cache-Control&lt;/span&gt; &lt;span class="s"&gt;public&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                          &lt;span class="c1"&gt;# Some browsers still send conditional-GET requests if there's a
&lt;/span&gt;                  &lt;span class="c1"&gt;# Last-Modified header or an ETag header even if they haven't
&lt;/span&gt;                  &lt;span class="c1"&gt;# reached the expiry date sent in the Expires header.
&lt;/span&gt;                  &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;Last-Modified&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                  &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;ETag&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                  &lt;span class="kn"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只需要注意的是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;upstream中 server 要配置成你在puma中bind的 socket就行了&lt;/li&gt;
&lt;li&gt;root要设置成你服务器项目的根目录，也就是&lt;code&gt;puma.rb&lt;/code&gt;中的 &lt;code&gt;directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下里只需要重启nginx服务器，整个rails的环境就搭建完成了&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
  nginx -s reload

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果完成了配置后访问站点是504，那么可能是两种情况，一是服务器防火墙问题，二是rails环境密钥的问题，请在&lt;a href="http://segmentfault.com/a/1190000002911605"&gt;使用passenger在Centos7部署nginx+Ruby on Rails&lt;/a&gt;中寻找答案&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Laravel(2) 登录重写</title>
    <link rel="alternate" href="http://blog.example.com/2015/06/16/laravel-2-login-rewrite/"/>
    <id>http://blog.example.com/2015/06/16/laravel-2-login-rewrite/</id>
    <published>2015-06-17T00:06:00+08:00</published>
    <updated>2015-06-17T00:11:48+08:00</updated>
    <summary type="html">&lt;h3 id="laravel-登录重写"&gt;laravel 登录重写&lt;/h3&gt;

&lt;p&gt;权限控制是几乎每套成熟系统不可缺少的一部分，我们使用的权限控制方法是rbac，我将在这个系列的文章一步步完成一个比较复杂的rbac权限控制。&lt;/p&gt;

&lt;p&gt;rbac权限控制是一个非常成熟的权限控制系统，其原理是给每个用户一个或多个角色 而每个角色对系统相应模块有访问权限,具体理论知识不多介绍。在我完成这个权限控制系统中，我将普通用户和管理员用户分开在数据库中存储，我们先完成普通用户的登录，这一部分相对于管理员用户会比较简单，同时也让大家理解下登录的流程。&lt;/p&gt;

&lt;h5 id="未登录用户跳转到登录页面"&gt;未登录用户跳转到...&lt;/h5&gt;</summary>
    <content type="html">&lt;h3 id="laravel-登录重写"&gt;laravel 登录重写&lt;/h3&gt;

&lt;p&gt;权限控制是几乎每套成熟系统不可缺少的一部分，我们使用的权限控制方法是rbac，我将在这个系列的文章一步步完成一个比较复杂的rbac权限控制。&lt;/p&gt;

&lt;p&gt;rbac权限控制是一个非常成熟的权限控制系统，其原理是给每个用户一个或多个角色 而每个角色对系统相应模块有访问权限,具体理论知识不多介绍。在我完成这个权限控制系统中，我将普通用户和管理员用户分开在数据库中存储，我们先完成普通用户的登录，这一部分相对于管理员用户会比较简单，同时也让大家理解下登录的流程。&lt;/p&gt;

&lt;h5 id="未登录用户跳转到登录页面"&gt;未登录用户跳转到登录页面&lt;/h5&gt;

&lt;p&gt;当我们访问某些一定要登录后才能使用的功能时 我们往往会有一个功能就是 如果没有登录的用户，就会直接跳转到登录功能 在laravel已经提供的代码中我们可以非常轻松完成这个功能&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HomeController&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;Controller&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;__construct&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;middleware&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'auth'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;index&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="nx"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'/home'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;'这是首页'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在随便一个需要进行登录才能使用的控制器中使调用auth这个控制器就可以了，这个控制器会去检查session中是否有登录信息来进行判断是否有没有登录 那么这个&amp;#39;auth&amp;#39;中间件在哪呢？&lt;/p&gt;

&lt;p&gt;laravel中所有中间件都在app/Http/Kernel中注册&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
  &lt;span class="k"&gt;protected&lt;/span&gt; &lt;span class="nv"&gt;$routeMiddleware&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="s1"&gt;'auth'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'App\Http\Middleware\Authenticate'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;'auth.basic'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'Illuminate\Auth\Middleware\AuthenticateWithBasicAuth'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;'guest'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'App\Http\Middleware\RedirectIfAuthenticated'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;'admin_auth'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'App\Http\Middleware\AdminPermissionCheck'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;];&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个数组中key是中间件的别名 value是中间件的路径 由此我们可以找到别名为auth的中间件&lt;/p&gt;

&lt;p&gt;找到App\Http\Middleware\Authenticate&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Closure&lt;/span&gt; &lt;span class="nv"&gt;$next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;guest&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$request&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;ajax&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Unauthorized.'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;401&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//这个方法会跳转到Auth控制器的getLogin方法 
&lt;/span&gt;                &lt;span class="c1"&gt;//如果没有 那么会自动跳转的视图文件夹下的auth login
&lt;/span&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;guest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'auth/login'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$request&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handle方法是调用中间件时调用的方法  其中guest是判断有没有登录的方法 这里我们最有可能需要改的地方就是如果没有登录跳转的方法  如上面代码所示 跳转的路径为auth/login（这个路径已经在路由中配好，跳转到Auth控制器中得getLogin方法）&lt;/p&gt;

&lt;h5 id="建立一个登录视图"&gt;建立一个登录视图&lt;/h5&gt;

&lt;p&gt;在AuthController中建立一个登录视图&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;getLogin&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;view&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"auth.login"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="表单数据验证"&gt;表单数据验证&lt;/h5&gt;

&lt;p&gt;表单数据验证在实现部分是postLogin方法中的 UserLoginRequest $req&lt;br&gt;
我们建立一个请求类来对表单进行数据验证 使用laravel 提供的php artsian make:request 能非常轻松的建立一个请求类&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UserLoginRequest&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;Request&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="sd"&gt;/**
   * Determine if the user is authorized to make this request.
   *
   * @return bool
   */&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;authorize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="sd"&gt;/**
   * Get the validation rules that apply to the request.
   *
   * @return array
   */&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;rules&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
      &lt;span class="c1"&gt;//再这里对表单提交字段进行过滤
&lt;/span&gt;      &lt;span class="s1"&gt;'identity'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'required|min:3|max:16'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="s1"&gt;'password'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'required|min:6|max:16'&lt;/span&gt;
    &lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;sanitize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;all&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="登录处理方法"&gt;登录处理方法&lt;/h5&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;postLogin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;UserLoginRequest&lt;/span&gt; &lt;span class="nv"&gt;$req&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

   &lt;span class="c1"&gt;//这里对传递过来得字段进行了处理 这个函数为我自己定义的函数 仅仅是为了演示用
&lt;/span&gt;     &lt;span class="nv"&gt;$identity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;generateLoginIdentity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$req&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;input&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
     &lt;span class="nv"&gt;$identity&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'password'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$req&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'password'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//验证用户账号密码
&lt;/span&gt;    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;attempt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$indentity&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
      &lt;span class="c1"&gt;//登录成功 记录用户登录时间和登录ip
&lt;/span&gt;      &lt;span class="nv"&gt;$user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="na"&gt;where&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'='&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;user&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;first&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
      &lt;span class="c1"&gt;// 触发一个事件
&lt;/span&gt;      &lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;\App\Events\UserLogin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;$req&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
      &lt;span class="c1"&gt;//重定向到想要访问的页面
&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;intended&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'/'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上述代码所示 你可以对传过来得数据根据业务需要做进一步的处理&lt;/p&gt;

&lt;p&gt;验证登录用户功能的代码是这一段$this-&amp;gt;auth-&amp;gt;attempt($indentity) 如果验证成功回返回true，这个函数是laravel自带Auth的一个方法 功能是去User表中匹配传过来的字段，如果需要验证更多字段,当验证成功后会将登录信息存入session中。当然Auth去查找匹配的表是可以更改的，我会在后面实现管理员用户的登录功能的时候演示怎么修改。&lt;/p&gt;

&lt;p&gt;然后可以在下面的代码中继续完成你的业务逻辑  如我代码中所示的触发一个事件来记录登录事件和登录ip&lt;/p&gt;

&lt;h5 id="已经登录-访问登录页面的自动跳转"&gt;已经登录 访问登录页面的自动跳转&lt;/h5&gt;

&lt;p&gt;如果已经登录了 再访问登录页面 显然我们不需要再出现登录视图让其登录，我们需要将其跳转到其他路径，这个路径依然是可以修改的&lt;/p&gt;

&lt;p&gt;首先我们看看再Auth控制器中哪里对是否已经登录进行判断&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;__construct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Guard&lt;/span&gt; &lt;span class="nv"&gt;$auth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Registrar&lt;/span&gt; &lt;span class="nv"&gt;$registrar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;


    &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;auth&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$auth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;registrar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$registrar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;middleware&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'guest'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'except'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;'getLogout'&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中这个except表示getLogout这个方法将不会受到这个中间件的影响 getLogout通常是登出方法&lt;/p&gt;

&lt;p&gt;在这个控制器的构造方法调用了一个中间件来对是否已经登录进行判断 ，通过查找kernel.php我们找到这个中间件&lt;br&gt;
是App\Http\Middleware\RedirectIfAuthenticated.php&lt;/p&gt;
&lt;pre class="highlight php"&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Closure&lt;/span&gt; &lt;span class="nv"&gt;$next&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="na"&gt;check&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
                     &lt;span class="c1"&gt;//跳转的路径
&lt;/span&gt;      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;RedirectResponse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'/'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$request&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要修改了上面代码中跳转的路径就可以了&lt;/p&gt;

&lt;h3 id="总结"&gt;总结&lt;/h3&gt;

&lt;p&gt;我们可以看到 laravel已经给我们封装了很多登录相关需要用到的功能 ，非常的完善，但也给了我们很大的自由随意去修改登录相关的流程，我们可以随意根据需要业务逻辑修改登录的功能。&lt;/p&gt;
</content>
  </entry>
</feed>
