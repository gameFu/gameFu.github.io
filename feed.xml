<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gameFu's Blog</title>
  <id>http://blog.example.com</id>
  <link href="http://blog.example.com"/>
  <link href="http://blog.example.com/feed.xml" rel="self"/>
  <updated>2016-09-14T17:10:00+08:00</updated>
  <author>
    <name>Site Author</name>
  </author>
  <entry>
    <title>influxdb continuous query实战总结</title>
    <link rel="alternate" href="http://blog.example.com/2016/09/14/influxdb/"/>
    <id>http://blog.example.com/2016/09/14/influxdb/</id>
    <published>2016-09-14T17:10:00+08:00</published>
    <updated>2016-09-19T17:41:13+08:00</updated>
    <summary type="html">&lt;h2 id="time-series-database(时序数据库)"&gt;Time series Database(时序数据库)&lt;/h2&gt;

&lt;p&gt;什么是时间序列数据？最简单的定义就是数据格式里包含timestamp字段的数据。比如股票市场的价格，环境中的温度，主机的CPU使用率等。但是又有什么数据是不包含timestamp的呢？几乎所有的数据都可以打上一个timestamp字段。时间序列数据更重要的一个属性是如何去查询它。在查询的时候，对于时间序列我们总是会带上一个时间范围去过滤数据。同时查询的结果里也总是会包含timestamp字段。&lt;/p&gt;

&lt;p&gt;在实际开发使用中，我们或许会有类似这...&lt;/p&gt;</summary>
    <content type="html">&lt;h2 id="time-series-database(时序数据库)"&gt;Time series Database(时序数据库)&lt;/h2&gt;

&lt;p&gt;什么是时间序列数据？最简单的定义就是数据格式里包含timestamp字段的数据。比如股票市场的价格，环境中的温度，主机的CPU使用率等。但是又有什么数据是不包含timestamp的呢？几乎所有的数据都可以打上一个timestamp字段。时间序列数据更重要的一个属性是如何去查询它。在查询的时候，对于时间序列我们总是会带上一个时间范围去过滤数据。同时查询的结果里也总是会包含timestamp字段。&lt;/p&gt;

&lt;p&gt;在实际开发使用中，我们或许会有类似这样的需求，收集一个时间段内大量的数据，然后利用这个时段内的数据进行统计运算这样的需求，时序数据库正是为这样的需求而定制的，以influxdb为例，数据存储跟传统数据库不一样，是以无序的形式存储，插入代价更低，并且时序数据库会提供大量与时间相关的函数，快速方便的进行我们需要的统计计算。在数据监控领域，时序数据库已经成了越来越多的选择&lt;/p&gt;

&lt;h2 id="influxdb"&gt;influxdb&lt;/h2&gt;

&lt;p&gt;InfluxDB 是一个开源分布式的时序、事件和指标数据库。使用 Go 语言编写，无需外部依赖。其设计目标是实现分布式和水平伸缩扩展。 它有三大特性：&lt;/p&gt;

&lt;p&gt;1.Time Series （时间序列）：你可以使用与时间有关的相关函数（如最大，最小，求和等）&lt;br&gt;
2.Metrics（度量）：你可以实时对大量数据进行计算&lt;br&gt;
3.Eevents（事件）：它支持任意的事件数据&lt;/p&gt;

&lt;h3 id="术语概念"&gt;术语概念&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;database&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相当于mysql中的database&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;measurement&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相当于mysql中的表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;point&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相当于mysql中的行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相当于mysql中的索引，只支持字符串类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;field&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相当于mysql中的列，支持多种类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;retention policy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存策略，这是influxdb特有的属性，rp指定数据在influxdb中的保存时间，时间已过，influxdb会自动清除数据（注：influxdb没有直接提供删除数据的接口，若要删除数据只能通过修改数据的rp来删除数据）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;continuous query&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;influxdb特色功能之一，相当于定时任务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h2 id="实战"&gt;实战&lt;/h2&gt;

&lt;p&gt;需求：制作一个视频pgc的实时播放量排行列表&lt;/p&gt;

&lt;p&gt;视频pgc相当于暴走漫画，暴走漫画旗下会有在各大视频网站都有自己的主页，每个站点都有自己的播放量，现在我们需要将这些pgc下面的数据聚合起来，并且需要获取最新的内容。如果每次取这个列表的时候都要重新算一遍，无疑十分的浪费，这个时候就可以使用influxdb的cq来实现这个功能，通过cq，我们能定时的算出pgc的排行榜，并写入一种新表中，每次我们读取数据的时候，只要去读那张表就可以了。&lt;/p&gt;

&lt;p&gt;&lt;img title="pgc-er图" alt="pgc-er" src="../../../../images/influxdb-er-1f4eab66.png" /&gt;&lt;/p&gt;

&lt;p&gt;team: pgc+站点名（如暴走漫画-youku）&lt;/p&gt;

&lt;h3 id="continuous-query设计"&gt;continuous query设计&lt;/h3&gt;

&lt;p&gt;首先先看一下我们实时抓取过来的数据的结构&lt;/p&gt;

&lt;p&gt;&lt;img title="pgc-数据结构" alt="pgc-er" src="../../../../images/influxdb-data-fcaba8b1.png" /&gt;&lt;/p&gt;

&lt;p&gt;pgc_name是指pgc的名称如暴走漫画，pgc_user_id指pgc+站点名的唯一标识， play_count是播放量&lt;/p&gt;

&lt;p&gt;由于原始数据得到的是pgc下的某个站点数据，因而我们需要将其各个站点的数据加起来，并且我们要做的是每小时更新的排行榜，因此我们需要每小时更新一次最新的数据。因此我们需要一个每小时执行一次的cq&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
CREATE CONTINUOUS QUERY sum1 ON rails BEGIN SELECT sum(play_num) INTO rails.pgc_rank FROM rails.pgc_data GROUP BY pgc_name, time(1h) END

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段cq所执行的是，每隔一小时，执行 &lt;code&gt;SELECT sum(play_num) INTO rails.pgc_rank FROM rails.pgc_data GROUP BY pgc_name&lt;/code&gt; 这条语句，这条语句通过group对数据进行分组计算，并写入一张新表pgc_rank中，这样一来我们要获取最新的排名数据，只需要去查pgc_rank这张表就行了。&lt;/p&gt;

&lt;p&gt;注意： cq执行的语句必须在group by中指定time否则将无法执行，同时，如果不手动指定RESAMPLE(也就是执行时间)，默认的执行时间间隔是group by 指定的时间间隔&lt;/p&gt;

&lt;p&gt;让我们来看下这条语句每小时具体执行了什么样的语句&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
SELECT sum(play_num) INTO rails.pgc_rank FROM rails.pgc_data WHERE time &amp;gt;= '2016-09-04T09:00:00Z' AND time &amp;lt; '2016-09-04T10:01:00Z' GROUP BY pcg_name, time(1h)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这个cq每次执行的时候，都以执行的时间为节点，去查一小时前的这个时间到现在内所有的数据，这样就避免了很多繁复的工作。当然influxdb在cq上提供了十分强大的可定制功能可以满足各种执行事的时间间隔，如执行时统计的是以执行的这个时间为节点的两个小时前到1个小时前之间的数据等等这样的需求&lt;/p&gt;

&lt;h3 id="回填continuous-query数据"&gt;回填continuous query数据&lt;/h3&gt;

&lt;p&gt;通过之前的语句我们也看到了，cq执行的时候是以这个cq的时间作为当前时间节点，这也就意味着，这个cq创建之前，所有的数据是都没有办法统计写入的，因此如果要想补充cq创建之前的数据，就只能手动回填数据，回填语句基本可以仿照cq执行的语句来操作。如我要回填2016-07-28到2016-09-04的数据，只需要执行类似于这样的语句就可以了&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
SELECT sum(play_num) INTO rails.pgc_rank FROM rails.pgc_data WHERE time &amp;gt;= '2016-07-28T09:00:00Z' AND time &amp;lt; '2016-09-04T10:01:00Z' GROUP BY pcg_name, time(1h)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="查询最新排行榜"&gt;查询最新排行榜&lt;/h3&gt;

&lt;p&gt;我在写这篇博客的时候，influxdb稳定版本为0.13, 测试版为1.0，截止到最新的测试版，influxdb并没有加入子查询功能(虽然很早的时候已经有了这个issue - -)，因此一条查询语句无法直接查出排行榜，只能查出，当前最新时段所有pgc的播放量数据，然后在用其他方式进行排序&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;select * from pgc_rank group by pgc_name order by desc limit 1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们写进的新表中存的是，各个pgc在各个时段上的总播放量排行，因此我们需要取最近的播放量进行排名，首先group by 分组，然后用order by desc对分组数据进行排序，最后只取每个分组中的第一个数据， order by desc在influxdb中默认是按时间倒序排列，同时，指定按时间倒序排列后就不能再指定其他的顺序排列，否则就会报错。&lt;/p&gt;

&lt;p&gt;去出来的数据最终是这个样子&lt;/p&gt;

&lt;p&gt;&lt;img title="pgc-排名" alt="pgc-rank" src="../../../../images/pgc_rank-1c51ca1f.png" /&gt;&lt;/p&gt;

&lt;h2 id="总结"&gt;总结&lt;/h2&gt;

&lt;p&gt;在使用influxdb的这个过程，充分感受到了他的强大之处，尤其是处理类似这种极度依赖时间的数据，influxdb的优势无比的明显，无论是性能，还是便利性都是高于传统数据库。但是influxdb还在蓬勃发展中，很多功能并不完善，但是有理由继续期待这个数据库。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>nginx https http端口转发 和 cors</title>
    <link rel="alternate" href="http://blog.example.com/2016/04/14/nginx-https-and-cors/"/>
    <id>http://blog.example.com/2016/04/14/nginx-https-and-cors/</id>
    <published>2016-04-14T16:03:00+08:00</published>
    <updated>2016-04-14T16:53:43+08:00</updated>
    <summary type="html">&lt;h3 id="nginx-https配置"&gt;nginx https配置&lt;/h3&gt;

&lt;p&gt;https的使用需要申请证书，证书需要去专门的CA申请，但是个人网站建议使用免费证书，可以节省不少费用，国内的免费证书申请网站有&lt;a href="https://www.wosign.com/"&gt;https://www.wosign.com/&lt;/a&gt;。国外的免费证书申请网站有&lt;a href="https://letsencrypt.org/"&gt;Let&amp;apos;s Encrypt&lt;/a&gt;,但是Let&amp;apos;s Encrypt的免费证书有效期只有90天，如果想长时间使用需要写定时脚本不断更新证书，具体操作可以看&lt;a href="https://imququ.com/post/letsencrypt-certificate.html"&gt;这篇博客&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;nginx上配置https比较简单只需要拿到crt证书，和证书的私钥在nginx上几行代码就可配置了&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;listen...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;h3 id="nginx-https配置"&gt;nginx https配置&lt;/h3&gt;

&lt;p&gt;https的使用需要申请证书，证书需要去专门的CA申请，但是个人网站建议使用免费证书，可以节省不少费用，国内的免费证书申请网站有&lt;a href="https://www.wosign.com/"&gt;https://www.wosign.com/&lt;/a&gt;。国外的免费证书申请网站有&lt;a href="https://letsencrypt.org/"&gt;Let&amp;#39;s Encrypt&lt;/a&gt;,但是Let&amp;#39;s Encrypt的免费证书有效期只有90天，如果想长时间使用需要写定时脚本不断更新证书，具体操作可以看&lt;a href="https://imququ.com/post/letsencrypt-certificate.html"&gt;这篇博客&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;nginx上配置https比较简单只需要拿到crt证书，和证书的私钥在nginx上几行代码就可配置了&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;listen 443;
ssl on;
ssl_certificate dsjstage.bao.tv_bundle.crt;
ssl_certificate_key dsjstage.bao.tv.key;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="https-和-http的端口转发"&gt;https 和 http的端口转发&lt;/h3&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
return 301 https://$host$request_uri;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="nginx-cors-配置"&gt;nginx cors 配置&lt;/h3&gt;

&lt;p&gt;js跨域问题是在实际开发中经常会遇到的情况，使用nginx解决跨越问题十分的方便。&lt;/p&gt;

&lt;p&gt;nginx实现跨域的简单流程是对于简单请求，如GET，只需要在HTTP Response后添加Access-Control-Allow-Origin。&lt;br&gt;
对于非简单请求，比如POST、PUT、DELETE等，浏览器会分两次应答。第一次preflight（method: OPTIONS），主要验证来源是否合法，并返回允许的Header等。第二次才是真正的HTTP应答。所以服务器必须处理OPTIONS应答。OPTIONS请求要做204处理。&lt;/p&gt;

&lt;p&gt;接下来是各个参数&lt;/p&gt;

&lt;p&gt;Access-Control-Allow-Origin（必含） – 允许的域名，只能填通配符或者单域名(尽量不要使用通配符)&lt;br&gt;
Access-Control-Allow-Methods（必含） – 这允许跨域请求的http方法（常见有POST、GET、OPTIONS）&lt;br&gt;
Access-Control-Allow-Headers（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。（设置时要注意查看http请求头的参数）&lt;br&gt;
Access-Control-Allow-Credentials（可选） – 该项标志着请求当中是否包含cookies信息，只有一个可选值：true（必为小写）。如果不包含cookies，请略去该项，而不是填写false。这一项与XmlHttpRequest2对象当中的withCredentials属性应保持一致，即withCredentials为true时该项也为true；withCredentials为false时，省略该项不写。反之则导致请求失败。&lt;br&gt;
Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。&lt;/p&gt;
&lt;pre class="highlight nginx"&gt;&lt;code&gt;
     &lt;span class="k"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Origin'&lt;/span&gt; &lt;span class="s"&gt;'xxxx'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Credentials'&lt;/span&gt; &lt;span class="s"&gt;'true'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Methods'&lt;/span&gt; &lt;span class="s"&gt;'GET,&lt;/span&gt; &lt;span class="s"&gt;POST,&lt;/span&gt; &lt;span class="s"&gt;DELETE,&lt;/span&gt; &lt;span class="s"&gt;PUT,&lt;/span&gt; &lt;span class="s"&gt;OPTIONS'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Headers'&lt;/span&gt; &lt;span class="s"&gt;'Accept,&lt;/span&gt; &lt;span class="s"&gt;Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$request_method&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'OPTIONS')&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Origin'&lt;/span&gt; &lt;span class="s"&gt;'xxxx'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Max-Age'&lt;/span&gt; &lt;span class="mi"&gt;1728000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Credentials'&lt;/span&gt; &lt;span class="s"&gt;'true'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Methods'&lt;/span&gt; &lt;span class="s"&gt;'GET,&lt;/span&gt; &lt;span class="s"&gt;POST,&lt;/span&gt; &lt;span class="s"&gt;DELETE,&lt;/span&gt; &lt;span class="s"&gt;PUT,&lt;/span&gt; &lt;span class="s"&gt;OPTIONS'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Access-Control-Allow-Headers'&lt;/span&gt; &lt;span class="s"&gt;'Accept,&lt;/span&gt; &lt;span class="s"&gt;Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Content-Type'&lt;/span&gt; &lt;span class="s"&gt;'text/plain&lt;/span&gt; &lt;span class="s"&gt;charset=UTF-8'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;'Content-Length'&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;204&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;



&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>gitlab_develop_ci</title>
    <link rel="alternate" href="http://blog.example.com/2016/03/15/gitlab_develop_ci/"/>
    <id>http://blog.example.com/2016/03/15/gitlab_develop_ci/</id>
    <published>2016-03-16T01:04:00+08:00</published>
    <updated>2016-03-16T17:02:45+08:00</updated>
    <summary type="html">&lt;h3 id="使用ci将项目部署到服务器"&gt;使用ci将项目部署到服务器&lt;/h3&gt;

&lt;h4 id="runner配置"&gt;runner配置&lt;/h4&gt;

&lt;p&gt;这篇文章中的服务器环境使用的是coreos，部署也是在docker中进行。runner是依然采用了上篇文章中使用的docker-runner执行&lt;/p&gt;

&lt;p&gt;在runner服务器上执行下面这段命令，生成执行ci的docker&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;docker run -d --name gitlab-runner1 --restart always \
             -v /var/run/docker.sock:/var/run/docker.sock \...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;h3 id="使用ci将项目部署到服务器"&gt;使用ci将项目部署到服务器&lt;/h3&gt;

&lt;h4 id="runner配置"&gt;runner配置&lt;/h4&gt;

&lt;p&gt;这篇文章中的服务器环境使用的是coreos，部署也是在docker中进行。runner是依然采用了上篇文章中使用的docker-runner执行&lt;/p&gt;

&lt;p&gt;在runner服务器上执行下面这段命令，生成执行ci的docker&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;docker run -d --name gitlab-runner1 --restart always \
             -v /var/run/docker.sock:/var/run/docker.sock \
             -v /srv/gitlab-runner/config:/etc/gitlab-runner \
             -v /root/.ssh/id_rsa:/root/id_rsa \
             gitlab/gitlab-runner:latest

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要重点解释的是 &lt;code&gt;-v /root/.ssh/id_rsa:/root/id_rsa \&lt;/code&gt;，这个命令会将runner服务器上的私钥挂载到容器里面，这么做的原因是执行部署的时候需要ssh连接到目标服务器上，必须先将服务器私钥挂载进去才能在docker里面连接到服务器(这种方法并不好)。当然，首先我们需要在服务器上配好密钥，并且将公钥放到目标服务器上，这里就不详细解释怎么做了。&lt;/p&gt;

&lt;p&gt;接下来运行&lt;code&gt;docker exec -it gitlab-runner gitlab-runner register&lt;/code&gt; 进行runner注册，我使用的executor是ssh，使用这个executor可以远程连接到目标服务器并进行操作&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;Please enter the gitlab-ci tags for this runner (comma separated):
docker-develop
Registering runner... succeeded                     runner=_m_ivm6R
Please enter the executor: ssh, shell, parallels, docker, docker-ssh, virtualbox:
ssh
Please enter the SSH server address (eg. my.server.com):
xxxxx
Please enter the SSH server port (eg. 22):
22
Please enter the SSH user (eg. root):
root
Please enter the SSH password (eg. docker.io):

Please enter path to SSH identity file (eg. /home/user/.ssh/id_rsa):
/root/id_rsa

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：最后要求填入SSH identity file的路径是指容器内id_rsa的路径，而不是runner服务器的id_rsa的路径&lt;/p&gt;

&lt;p&gt;如果需要修改runner的配置，可以去find config.toml ,里面配置了runner的所有信息&lt;/p&gt;

&lt;h4 id="deploy.sh"&gt;deploy.sh&lt;/h4&gt;

&lt;p&gt;这里我将部署的工作写在了bash脚本里，然后执行ci时，直接执行这段脚本即可，这里只演示最简单的部署工作&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;containerName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;action_cable
&lt;span class="nv"&gt;imageName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;daocloud.io/gamefu/action_cable:latest

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"镜像名{&lt;/span&gt;&lt;span class="nv"&gt;$imageName&lt;/span&gt;&lt;span class="s2"&gt;}"&lt;/span&gt;

&lt;span class="c"&gt;# 拉取最新镜像&lt;/span&gt;
docker pull &lt;span class="nv"&gt;$imageName&lt;/span&gt;
&lt;span class="c"&gt;# 删除老容器&lt;/span&gt;
docker stop &lt;span class="nv"&gt;$containerName&lt;/span&gt;
docker rm &lt;span class="nv"&gt;$containerName&lt;/span&gt;
&lt;span class="c"&gt;# 运行新容器&lt;/span&gt;
docker run --name &lt;span class="nv"&gt;$containerName&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
          -e &lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;C.UTF-8 &lt;span class="se"&gt;\&lt;/span&gt;
          -e &lt;span class="nv"&gt;RAILS_ENV&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;production &lt;span class="se"&gt;\&lt;/span&gt;
          --link action_cable_mysql:mysql &lt;span class="se"&gt;\&lt;/span&gt;
          -d &lt;span class="nv"&gt;$imageName&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=".gitlab-ci.yml"&gt;.gitlab-ci.yml&lt;/h4&gt;

&lt;p&gt;ci设置&lt;/p&gt;
&lt;pre class="highlight yaml"&gt;&lt;code&gt;
&lt;span class="s"&gt;staging_build&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;script&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;source stag_deploy.sh&lt;/span&gt;
  &lt;span class="s"&gt;only&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;develop&lt;/span&gt;
  &lt;span class="s"&gt;tags&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
    &lt;span class="pi"&gt;-&lt;/span&gt; &lt;span class="s"&gt;docker-develop&lt;/span&gt;
  &lt;span class="s"&gt;type&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;deploy&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;only设置只有在develop分支合并或者push新内容时，执行这个ci&lt;/p&gt;

&lt;p&gt;这样一来基本的ci部署完成了。。&lt;/p&gt;

&lt;h3 id="总结"&gt;总结&lt;/h3&gt;

&lt;p&gt;这篇文章算是我在爬坑的记录，后来我跟同事讨论，并且仔细一想之后，有几点觉得可以改进，首先是runner，由于ci做部署的时候，需要使用ssh连接到服务器，所以executor需要用ssh,而ssh本来就不应该运行到docker runner里面，而是应该直接运行到runner服务器上，这样就避免了很多像id_rsa找不到的各种坑，以及在做测试的时候遇到需要docker-login的时候，需要将/root/.docker/config.json挂载到docker里面的情况&lt;/p&gt;

&lt;p&gt;经过这次爬坑后，个人觉得，runner应该直接安装在服务器上，test-ci使用docker executor，使用docker executor就能避免很多环境依赖问题, develop-ci使用ssh executor是更加合理的做法&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>centos7下完整配置gitlab及gitlab-ci docker测试</title>
    <link rel="alternate" href="http://blog.example.com/2016/03/08/gitlab_and_ci_deploy/"/>
    <id>http://blog.example.com/2016/03/08/gitlab_and_ci_deploy/</id>
    <published>2016-03-08T22:36:00+08:00</published>
    <updated>2016-03-14T00:12:05+08:00</updated>
    <summary type="html">&lt;h3 id="gitlab下载"&gt;gitlab下载&lt;/h3&gt;

&lt;p&gt;由于直接从官方渠道下载会遭遇被墙的情况，因此，先更换成中国镜像，再进行下载安装&lt;/p&gt;

&lt;p&gt;参照&lt;a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/"&gt;gitlab中国镜像下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装完成后运行下面命令，配置gitlab&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl reconfigure

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="gitlab服务"&gt;gitlab服务&lt;/h3&gt;

&lt;h4 id="开启gitlab服务"&gt;开启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl start

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="停止gitlab服务"&gt;停止gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl stop

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="重启gitlab服务"&gt;重启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl restart

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="开启rails控制台"&gt;开启rails控制台&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-rails console...&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;h3 id="gitlab下载"&gt;gitlab下载&lt;/h3&gt;

&lt;p&gt;由于直接从官方渠道下载会遭遇被墙的情况，因此，先更换成中国镜像，再进行下载安装&lt;/p&gt;

&lt;p&gt;参照&lt;a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/"&gt;gitlab中国镜像下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装完成后运行下面命令，配置gitlab&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl reconfigure

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="gitlab服务"&gt;gitlab服务&lt;/h3&gt;

&lt;h4 id="开启gitlab服务"&gt;开启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl start

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="停止gitlab服务"&gt;停止gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
gitlab-ctl stop

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="重启gitlab服务"&gt;重启gitlab服务&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl restart

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="开启rails控制台"&gt;开启rails控制台&lt;/h4&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-rails console

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="配置gitlab服务"&gt;配置gitlab服务&lt;/h3&gt;

&lt;p&gt;首先需要修改gitlab的external_url，external_url是gitlab默认仓库的host地址，我们需要将其改成外网可以访问的地址，如ip&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
vim /etc/gitlab/gitlab.rb

&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="n"&gt;external_url&lt;/span&gt; &lt;span class="s1"&gt;'http://121.201.63.89'&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们需要配置一下smtp服务器，同样在gitlab.rb&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="c1"&gt;# 配置smtp服务器信息&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_enable'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_address'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"smtp.163.com"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_port'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_user_name'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxuser@163.com"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_password'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxpassword"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_domain'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"163.com"&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_authentication'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;:login&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'smtp_enable_starttls_auto'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;

&lt;span class="c1"&gt;# 配置发送人信息&lt;/span&gt;
&lt;span class="n"&gt;gitlab_rails&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'gitlab_email_from'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxuser@163.com"&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"git_user_email"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"xxuser@163.com"&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gitlab读取最新更改配置&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;gitlab-ctl reconfigure

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="配置gitlab-ci"&gt;配置gitlab-ci&lt;/h3&gt;

&lt;h4 id="添加.gitlab-ci.yml-到项目下"&gt;添加.gitlab-ci.yml 到项目下&lt;/h4&gt;

&lt;h4 id="配置gitlab-ci-runner"&gt;配置gitlab-ci runner&lt;/h4&gt;

&lt;p&gt;gitlab-ci runner是负责运行ci测试的服务， runner可以执行多个项目的ci测试&lt;/p&gt;

&lt;p&gt;首先需要先安装gitlab-ci runner&lt;/p&gt;

&lt;p&gt;runner 有许多种形式，这里我们使用了docker的形式运行，使用docker运行有几点好处，一是不用再runner环境下配置ruby运行需要的所有依赖库，降低了配置的难度，同时也避免了由于操作系统，源等差异带来的版本冲突问题&lt;/p&gt;

&lt;p&gt;参照&lt;a href="https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/install/docker.md"&gt;Install as Docker Service&lt;/a&gt;&lt;/p&gt;

&lt;h5 id="note"&gt;note&lt;/h5&gt;

&lt;p&gt;如果遇到&lt;br&gt;
```&lt;br&gt;
ERROR: Build failed with: Get &lt;a href="http://unix.sock/v1.18/version:"&gt;http://unix.sock/v1.18/version:&lt;/a&gt; dial unix /var/run/docker.sock: no such file or directory&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;
这是因为没有把docker.sock挂载到容器里，导致无法拉取镜像

这时，run gitlab-runner容器时，需要指定挂载docker.sock

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker run -d --name gitlab-runner --restart always \&lt;br&gt;
  -v /var/run/docker.sock:/var/run/docker.sock \&lt;br&gt;
  -v /srv/gitlab-runner/config:/etc/gitlab-runner \&lt;br&gt;
  gitlab/gitlab-runner:latest&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;

#### 配置.gitlab-ci.yml

```yaml

# 主镜像
image: docker.baozou.com/baozou/dashijian:base
services:
  # 依赖的镜像
  - mysql:latest
# 环境变量
variables:
  # Configure mysql environment variables (https://hub.docker.com/_/mysql/)
  MYSQL_DATABASE: action_cabel
  MYSQL_ROOT_PASSWORD: '63292590'

test:
  script:
    # 拉取子模块
    - git submodule update --init
    # 在gitlab docker runner中/cache是会被挂在容器外面的地方，将bundle下来的gem包安装在这个地方，能避免test每次bundle的时候都重新拉下完整的gem
    - bundle install --path=/cache
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake db:drop
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake db:create
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake db:migrate
    - RAILS_ENV=test DB_HOST=mysql DB_NAME=action_cable bundle exec rake test
  tags:
    - docker-test


&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>在coreos上用docker部署rails应用</title>
    <link rel="alternate" href="http://blog.example.com/2015/07/09/deploy-docker-passenger-rails-in-coreos/"/>
    <id>http://blog.example.com/2015/07/09/deploy-docker-passenger-rails-in-coreos/</id>
    <published>2015-07-09T12:08:00+08:00</published>
    <updated>2016-03-08T22:38:06+08:00</updated>
    <summary type="html">&lt;h3 id="coreos上的配置"&gt;coreos上的配置&lt;/h3&gt;

&lt;p&gt;coreos没有包管理工具，也不鼓励使用包管理工具来解决依赖关系，他提倡使用docker等容易来解决管理以来，要想搭建一个rails的环境，我们需要创建一个能满足我们需求的镜像。docker原则上是一个服务就需要一个镜像，不同的服务之间通讯需要使用docker自己提供的通讯方式，这个演示实例里，我们只依赖于一个数据库服务。首先我们需要创建我们整个rails运行环境所需要的所有服务镜像&lt;/p&gt;

&lt;p&gt;postgres数据库的官方镜像&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker pull postgres

&lt;/code&gt;&lt;/pre&gt;</summary>
    <content type="html">&lt;h3 id="coreos上的配置"&gt;coreos上的配置&lt;/h3&gt;

&lt;p&gt;coreos没有包管理工具，也不鼓励使用包管理工具来解决依赖关系，他提倡使用docker等容易来解决管理以来，要想搭建一个rails的环境，我们需要创建一个能满足我们需求的镜像。docker原则上是一个服务就需要一个镜像，不同的服务之间通讯需要使用docker自己提供的通讯方式，这个演示实例里，我们只依赖于一个数据库服务。首先我们需要创建我们整个rails运行环境所需要的所有服务镜像&lt;/p&gt;

&lt;p&gt;postgres数据库的官方镜像&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker pull postgres

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们还需要运行rails的web服务器镜像，我选择的是passenger的官方镜像&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker pull phusion/passenger-ruby22

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rails运行需要postgres数据库，因此，我们需要创建一个postgres容器,同时给我们创建的容器一个名称&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker run --name gamePostgres -d postgres

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来我们在coreos上的配置就配置好了&lt;/p&gt;

&lt;h3 id="dockerfile"&gt;Dockerfile&lt;/h3&gt;

&lt;p&gt;将这个Dockerfile加入我们的rails项目下&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;
&lt;span class="c1"&gt;# 以phusion/passenger-ruby22镜像为基础&lt;/span&gt;
&lt;span class="no"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;phusion&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;passenger&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ruby22&lt;/span&gt;

&lt;span class="c1"&gt;# 设置时区&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Asia/Shanghai"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="sr"&gt;/etc/&lt;/span&gt;&lt;span class="n"&gt;timezone&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;dpkg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;reconfigure&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;noninteractive&lt;/span&gt; &lt;span class="n"&gt;tzdata&lt;/span&gt;

&lt;span class="c1"&gt;#设置当前环境变量&lt;/span&gt;
&lt;span class="no"&gt;ENV&lt;/span&gt; &lt;span class="no"&gt;HOME&lt;/span&gt; &lt;span class="sr"&gt;/root
#设置rails环境为生产环境
ENV RAILS_ENV production

CMD ["/s&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;my_init&lt;/span&gt;&lt;span class="s2"&gt;"]

# 缓存gem，如果Gemfil没有改变将不会从源直接下载
WORKDIR /tmp
ADD ./Gemfile Gemfile
ADD ./Gemfile.lock Gemfile.lock
RUN bundle install

#启动nginx
RUN rm -f /etc/service/nginx/down
#配置nginx
RUN rm /etc/nginx/sites-enabled/default
ADD nginx.conf /etc/nginx/sites-enabled/webapp.conf

#添加环境文件
ADD nginx-env.conf /etc/nginx/main.d/nginx-env.conf

#增加初始化运行脚本
RUN mkdir -p /etc/my_init.d
#Migrate
ADD migrate.sh /etc/my_init.d/migrate.sh
RUN chmod +x /etc/my_init.d/migrate.sh

# 创建项目目录
RUN mkdir /home/app/webapp
# 将项目文件加入项目目录
ADD . /home/app/webapp

WORKDIR /home/app/webapp
# 编译静态文件
RUN rake assets:precompile

# 清楚产生的缓存文件
RUN apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
# 开放80端口
EXPOSE 80


&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于passenger镜像是建立在nginx的基础上地，所以我们需要配置nginx.同时在跟目录创建nginx.conf.&lt;/p&gt;
&lt;pre class="highlight nginx"&gt;&lt;code&gt;
&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;#指定项目根目录
&lt;/span&gt;    &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="n"&gt;/home/app/webapp/public&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# 开启passenger
&lt;/span&gt;    &lt;span class="kn"&gt;passenger_enabled&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;passenger_user&lt;/span&gt; &lt;span class="s"&gt;app&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;client_max_body_size&lt;/span&gt; &lt;span class="mi"&gt;20M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;passenger_max_request_queue_size&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在docker中服务通讯必须在容器之间暴露端口，因此我们需要添加env文件来暴露各容器之间的端口,在项目根目录下创建nginx-env.conf文件&lt;/p&gt;
&lt;pre class="highlight nginx"&gt;&lt;code&gt;
&lt;span class="c1"&gt;# 暴露服务端口 这个示例中只有postgres服务，因此我们只需要暴露这个端口即可
&lt;/span&gt;&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;POSTGRES_PORT_5432_TCP_ADDR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;POSTGRES_PORT_5432_TCP_PORT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们配置一下.gitignore，在.gitignore文件里加上,因为服务器的数据库配置和本地数据库配置不一样&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;/config/database.yml

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时copy一份database.yml，将其改名为database.yml.sample&lt;/p&gt;

&lt;h3 id="在coreos上部署"&gt;在coreos上部署&lt;/h3&gt;

&lt;p&gt;coreos虽然默认没有带包管理工具，但是安装了git之类的常用工具，因此，我们可以使用git部署我们的项目，将我们的项目上传到github，然后在coreos的某个目录将整个项目拉下来。我选择的是/root/apps目录&lt;/p&gt;

&lt;p&gt;拉取项目后，我们首先需要更改的是数据库配置文件database.yml&lt;/p&gt;
&lt;pre class="highlight yaml"&gt;&lt;code&gt;
&lt;span class="s"&gt;default&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;&amp;amp;default&lt;/span&gt;
  &lt;span class="s"&gt;adapter&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;postgresql&lt;/span&gt;
  &lt;span class="s"&gt;encoding&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;unicode&lt;/span&gt;
  &lt;span class="s"&gt;pool&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;5&lt;/span&gt;
  &lt;span class="s"&gt;timeout&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;5000&lt;/span&gt;
  &lt;span class="s"&gt;username&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;postgres&lt;/span&gt;
  &lt;span class="s"&gt;password&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="c1"&gt;# 通过暴露出来的地址和端口配置数据库&lt;/span&gt;
  &lt;span class="s"&gt;host&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;%= ENV['POSTGRES_PORT_5432_TCP_ADDR'] %&amp;gt;&lt;/span&gt;
  &lt;span class="s"&gt;port&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;%= ENV['POSTGRES_PORT_5432_TCP_PORT'] %&amp;gt;&lt;/span&gt;
&lt;span class="s"&gt;development&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;*default&lt;/span&gt;
  &lt;span class="s"&gt;database&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;sample_dev&lt;/span&gt;

&lt;span class="c1"&gt;# Warning: The database defined as "test" will be erased and&lt;/span&gt;
&lt;span class="c1"&gt;# re-generated from your development database when you run "rake".&lt;/span&gt;
&lt;span class="c1"&gt;# Do not set this db to the same as development or production.&lt;/span&gt;
&lt;span class="s"&gt;test&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;*default&lt;/span&gt;
  &lt;span class="s"&gt;database&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;sample_test&lt;/span&gt;

&lt;span class="s"&gt;production&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt;
  &lt;span class="s"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;*default&lt;/span&gt;
  &lt;span class="s"&gt;database&lt;/span&gt;&lt;span class="pi"&gt;:&lt;/span&gt; &lt;span class="s"&gt;sample_production&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入项目根目录，通过Dockfile构建一个镜像,并且给自己创建的镜像一个名称&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker build -t game/ruby_sample .

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后的每一次更改项目内容都需要重新构建一个新的镜像，如果你是第一次生成容器可以不用运行下面这条命令，如果你之前已经创建过同名的容易就需要将其删除，如我之前这个容器名为gameRuby_sample,那么我就需要将这个容器删除后重新创建&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker rm -f gameRuby_sample

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建新的容器，并且建立容器之间的通讯，监听服务器的80端口&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
docker run --name gameRuby_sample --link gamePostgres:postgres -d -p 80:80 game/ruby_sample

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行到这里，一个完整的rails容器已经基本建立完成了。然而整个容器还缺乏一个很关键的部分没解决，就是运行rails程序的migrate，由于，migrate必须在整个容器建立完成之后才能运行，因此无法直接将其写在&lt;code&gt;Dockerfile&lt;/code&gt;内，只有当运行容器时运行，才能有效果。&lt;br&gt;
passenger是根据ubuntu镜像的基础上搭建的，也就是说，这个系统的启动流程跟ubuntu启动的流程是一样的，当ubuntu系统完成引导后，操作系统会去检查/etc/my_init.d/目录下的脚本，并且会运行，这样一来，只需把migrate的执行脚本放到这个目录下面，那么就会在镜像启动的时候运行Migrate。&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="c1"&gt;#增加初始化运行脚本&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="sr"&gt;/etc/m&lt;/span&gt;&lt;span class="n"&gt;y_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;d&lt;/span&gt;
&lt;span class="c1"&gt;#Migrate&lt;/span&gt;
&lt;span class="no"&gt;ADD&lt;/span&gt; &lt;span class="n"&gt;migrate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sh&lt;/span&gt; &lt;span class="sr"&gt;/etc/m&lt;/span&gt;&lt;span class="n"&gt;y_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;migrate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sh&lt;/span&gt;
&lt;span class="no"&gt;RUN&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="sr"&gt;/etc/m&lt;/span&gt;&lt;span class="n"&gt;y_init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;migrate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;sh&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是migrate运行脚本&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"start migrate"&lt;/span&gt;
bash -c &lt;span class="s1"&gt;'cd /home/app/webapp; bundle exec rake db:migrate'&lt;/span&gt;;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"migrate finshed"&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要运行docker run后，运行&lt;code&gt;docker logs -f 镜像名&lt;/code&gt;，能看到&lt;code&gt;start migrate&lt;/code&gt;和&lt;code&gt;migrate finshed&lt;/code&gt;就说明镜像已经成功运行migrate了&lt;/p&gt;

&lt;p&gt;这样一来基本的rails运行环境就搭建完成了&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>coreos中更改docker镜像地址</title>
    <link rel="alternate" href="http://blog.example.com/2015/07/06/coreos-modify-docker-registry-mirror/"/>
    <id>http://blog.example.com/2015/07/06/coreos-modify-docker-registry-mirror/</id>
    <published>2015-07-06T23:45:00+08:00</published>
    <updated>2015-07-07T00:25:43+08:00</updated>
    <summary type="html">&lt;p&gt;由于&lt;code&gt;docker&lt;/code&gt;的不断成熟，docker在实际生产环境中的应用已经得到越来越多的印证，因此，公司项目想从原来的Mina部署转为&lt;code&gt;docker&lt;/code&gt;部署，但是docker仓库由于在国内没有cdn，导致镜像下载速度无比的缓慢，所以决定换成国内镜像，由于操作系统是使用&lt;code&gt;coreos&lt;/code&gt;，无论国内外资料都非常少，因此途中爬了很多坑，这篇文章是我爬坑的总结&lt;/p&gt;

&lt;h3 id="docker国内镜像"&gt;docker国内镜像&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;是目前炙手可热的云计算开源项目，随着docker不断发展，不久前，国内第一家基于&lt;code&gt;docker&lt;/code&gt;技术的一站式容器云平台daocloud...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;由于&lt;code&gt;docker&lt;/code&gt;的不断成熟，docker在实际生产环境中的应用已经得到越来越多的印证，因此，公司项目想从原来的Mina部署转为&lt;code&gt;docker&lt;/code&gt;部署，但是docker仓库由于在国内没有cdn，导致镜像下载速度无比的缓慢，所以决定换成国内镜像，由于操作系统是使用&lt;code&gt;coreos&lt;/code&gt;，无论国内外资料都非常少，因此途中爬了很多坑，这篇文章是我爬坑的总结&lt;/p&gt;

&lt;h3 id="docker国内镜像"&gt;docker国内镜像&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;是目前炙手可热的云计算开源项目，随着docker不断发展，不久前，国内第一家基于&lt;code&gt;docker&lt;/code&gt;技术的一站式容器云平台daocloud正式推出了，同时也给国内广大docker爱好者带来了docker的免费国内镜像.前往docker的官网注册一个账号登录后就能得到一个免费的docker镜像地址，如&lt;a href="http://xxx.m.daocloud.io"&gt;http://xxx.m.daocloud.io&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="关于coreos"&gt;关于coreos&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;coreos&lt;/code&gt;是一个高度精简的linux操作系统，将许多原本需要复杂人工操作或者第三方软件支持的功能在操作系统级别进行了实现，同时剔除了其他对于服务器系统非核心的软件，比如GUI和包管理器。&lt;code&gt;coreos&lt;/code&gt;并不鼓励用户将各种应用软件直接安装在操作系统之上，而是提倡将所有服务运行在单独的应用容器中，由应用容器提供应用所需要的基础功能环境。这种做法将操作系统和应用程序的职责做了更彻底的分离，降低操作系统和应用程序的耦合度，使运行这些服务器的公司可以更快速、更廉价地更新自己的线上业务。&lt;br&gt;
正式这种特性，&lt;code&gt;coreos&lt;/code&gt;可以说十分适合用来部署&lt;code&gt;docker&lt;/code&gt;服务&lt;/p&gt;

&lt;h3 id="更改docker镜像地址"&gt;更改docker镜像地址&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;在&lt;code&gt;coreos&lt;/code&gt;中是一个服务，在&lt;code&gt;coreos&lt;/code&gt;中没一个服务都由一个unit文件来定义，&lt;code&gt;docker&lt;/code&gt;的unit文件在&lt;code&gt;usr/lib/systemd/system/docker.service&lt;/code&gt;,我们需要将它拷贝出来将其放在docker服务启动时会加载的位置&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
cp /usr/lib/systemd/system/docker.service /etc/systemd/system

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开这种文件，我们会发现里面有一个更改docker镜像地址的关键环境变量&lt;code&gt;$DOCKER_OPTS&lt;/code&gt;，而更改镜像地址的本质就是更改&lt;code&gt;$DOCKER_OPTS&lt;/code&gt;的值。&lt;br&gt;
这个环境变量的值是在&lt;code&gt;/run/flannel_docker_opts.env&lt;/code&gt;中设置的，如果你的系统里没有这个文件，就自己添加一个这个文件&lt;/p&gt;

&lt;p&gt;往这个文件里添加从daocloud上获取的镜像地址&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
&lt;span class="nv"&gt;DOCKER_OPTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"--registry-mirror=http://xxxx.m.daocloud.io"&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完成后，运行&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
sudo systemctl daemon-reload
sudo systemctl restart docker

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 &lt;code&gt;ps aux&lt;/code&gt; 如果能看到&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt;
root      1725  0.6  1.7 221400 18328 ?        Ssl  15:27   0:00 docker --daemon --host&lt;span class="o"&gt;=&lt;/span&gt;fd:// --registry-mirror&lt;span class="o"&gt;=&lt;/span&gt;http://xxx.m.daocloud

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么就大功告成了&lt;/p&gt;

&lt;h3 id="总结"&gt;总结&lt;/h3&gt;

&lt;p&gt;虽然整个配置流程看起来并不复杂，但是使用比较新的技术难免要爬坑，由于国内外资料都非常的少，导致爬坑异常的艰难，希望大家能节省爬过这个坑的时间。&lt;/p&gt;
</content>
  </entry>
</feed>
